#1#::#1#::#0#::#0#::#0#::#1#::#1#/rubin/system/daemond.rb?/rubin/system/controller.rb?/rubin/system/definitions.rb?/rubin/system/dictionary.rb?/rubin/system/host.rb?/rubin/system/install.rb?/rubin/system/instance.rb?/rubin/launch.rb?/rubin/launch irb.cmd?/rubin/system/network.rb?/rubin/system/rubin.rb?/rubin/system/ruby.rb??/rubin/system?/rubin/app?/rubin/class?/rubin/data?/rubin/shortcuts?/rubin/data/appdata?/rubin/data/backups?/rubin/data/config?/rubin/data/definitions?/rubin/data/fileio?/rubin/data/logs?/rubin/data/scripts?/rubin/data/sys?/rubin/data/sys/instance?/rubin/data/temp?/rubin/data/user#1#::#0#::#0#::#0#::#0#::#0#::#1#/rubin/system/daemond.rb#1#::#1#::#0#::#0#::#0#::#0#::#1###;##;##;##;##;;;;;## Daemond is our Rubin systems background workings.;;;;;## This file is ran in the context of main>Rubin_System>Daemond;;;;;## The Daemond class requires instance variables defined in this file;;;;;## to be of the Thread class.;;;;;##;;;;;##;;;;;##;;;;;;;;;;@daemond=Thread.new{loop do;;;;;  ##create instance tag by writing the time in a file to show we are running;;;;;  begin;;;;;  fp=SYSTEM.datadir+"/sys/instance/"+INSTANCE.to_s+".dat";;;;;  f=File.open(fp,"w");f.write(Time.stamp);f.close;;;;;  ##scan all instance files and remove any abandoned instances(clicking close with out shutting down or some other abrupt exit);;;;;  i=Dir.entries(SYSTEM.datadir+"/sys/instance")[2..-1];;;;;  if i.length>0;;;;;    i.each do |ii|;;;;;	  fp=SYSTEM.datadir+"/sys/instance/"+ii;;;;;	  str=File.read(fp);;;;;	  if str.length==0;;;;;	    File.delete(fp)	;;;;;		SYSTEM.writelog("Outdated and corrupted instance file removed. ("+ii.to_s+")");;;;;	  else;;;;;	    stamp=Time.stamp(str);;;;;	    sec=Time.now-stamp;;;;;	    if sec.to_i>15;;;;;	      File.delete(fp)	;;;;;		  SYSTEM.writelog("Outdated instance file removed. ("+ii.to_s+" ; "+str.to_s+" )");;;;;	    end;;;;;	  end;;;;;	end;;;;;  end;;;;;  rescue;# SYSTEM.errorlog "Instance update thread had a write failure.";;;;;  end;;;;;  sleep 5;;;;;  ;;;;;  ;;;;;;;;;;end};;;;;;;;;;;;;;;@system_heartbeat=Thread.new{;;;;;  $system_heartbeat=0;;;;;  loop do;;;;;    ;;;;;	##most important few things are done here probably;;;;;    ;;;;;    $system_heartbeat+=1;;;;;    sleep 1;;;;;  end;;;;;};;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;##;##;##;##;###1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/controller.rb#1#::#1#::#0#::#0#::#0#::#0#::#1###controller 1.0.01 1-22-23 rubin instance-network controller, thomasjslone;;;;;# allows rubin to behave like a botnet;;;;;;;;;;class Controller          ## virtual network vis shared windows folders;;;;;    ;;;;;    ## new idea, we do this to track component versions seperate from system versions.;;;;;  ;;;;;  def initialize;;;;;    ;;;;;	@config_names=["Network_Directory","Network_Host","UserPriv"];;;;;	@default_config=["",""];;;;;	@config_data=@default_config;;;;;	;;;;;	@logpath=SYSTEM.datadir+"/logs/controller.txt";;;;;	;;;;;	@cfgpath=SYSTEM.datadir+"/config/controller.cfg";;;;;    if File.file?(@cfgpath) == false;  self.save_config;;;;;	else;  self.load_config;;;;;	end;;;;;    ;;;;;	@controller_state="initialized";;;;;    @binding=nil;;;;;    @network_directory=''   ;;;;;	@fileio_directory=SYSTEM.datadir+"/fileio";;;;;	@bound=false   ;;;;;	   ;;;;;	@dir_cleaner_thread=nil;;;;;;;;;;  end;;;;;;;;;;  def cleaning?;  return @dir_cleaner_thread.alive?;  end;;;;;;;;;;  def post_initialization  ## since we dont do any initializing in this file we dont call this here either, rubin system does after running this file;;;;;    @controller_state ="post_initialization"	;;;;;	;;;;;	if File.directory?(SYSTEM.config(7).to_s);;;;;	  @network_directory=SYSTEM.config(7).to_s;;;;;	  self.start_main_binding;;;;;	  SYSTEM.writelog("Controller bound to dir:"+@network_directory.to_s);;;;;	elsif SYSTEM.config(7).to_s=="" or SYSTEM.config(7) == nil or SYSTEM.config(7).to_s == "false";;;;;      @network_directory=@fileio_directory;;;;;	  SYSTEM.writelog("Controller network directory not set, using fileio dir but not launching control binding.");;;;;	  @controller_state = "inactive";;;;;	else;;;;;	  SYSTEM.errorlog "Controller network directory was invalid, you can reconfigure it using SYSTEM.config(7,'path')."	  ;;;;;	  @controller_state = "failed init";;;;;	end;;;;;    return nil;;;;;  end;;;;;  ;;;;;  ;;;;;  def start_main_binding;;;;;    if @binding != nil;  return false;  end;;;;;	@binding=FileIO_Eval_Binder.new(@network_directory,"eval",true);;;;;    @binding.start;;;;;	@bound=true;;;;;	if File.file?(@network_directory+"/cleaner.tag") == false  ##if you have problems with files not getting deleted just run the cleaner thread manually for now;;;;;	  self.spawn_dir_cleaner  ;;;;;	else;;;;;	  s=File.read(@network_directory+"/cleaner.tag");;;;;	  str=Time.stamp(s.to_s);;;;;	  tn=Time.now-str;;;;;	  if tn.to_i>9;;;;;	    self.spawn_dir_cleaner;;;;;	  end;;;;;	end;;;;;    @controller_state = "running";;;;;	return true;;;;;  end;;;;;  ;;;;;  def stop_main_binding;;;;;    @binding.stop;  @binding=nil; @state="stopped";;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;;;;;;  def spawn_dir_cleaner;;;;;    if @dir_cleaner_thread!=nil;  return false;  end;;;;;	;;;;;    @cleaning_thread=Thread.new{loop do;;;;;	  begin;  f=File.open(@network_directory+"/cleaner.tag","w");  f.write(Time.stamp);  f.close;  rescue; SYSTEM.errorlog "Controller cleaner thread failed to write tag file." ;  end;;;;;;;;;;	  begin;;;;;	  e=[];;;;;	  Dir.entries(@network_directory)[2..-1].each { |v| e << @network_directory+"/"+v.to_s };;;;;	  ;;;;;	  ;;;;;	  e.each do |ee|;;;;;	    if ee.split("/")[-1][0..11]=="fileio_link-";;;;;	      fp = ee;;;;;		  begin;  str=File.read(fp);;;;;		  rescue;  SYSTEM.errorlog("Controller dir cleaner thread had a read failure so the loop itteration was skipped.");  next;;;;;		  end;;;;;		  str2=Time.stamp(str);;;;;		  tn = Time.now;;;;;		  sec=tn-str2;;;;;		  if sec.to_f>9;;;;;		    i=ee.split("/")[-1][12..-5];;;;;			d=ee.split("/")[0..-2].join("/");;;;;		    fp1=d+"/fileio_input"+i.to_s+".txt";;;;;		    fp2=d+"/fileio_output"+i.to_s+".txt";;;;;			begin ; File.delete(ee) ; rescue ;; end;;;;;		    begin ; File.delete(fp1) ; rescue ;; end;;;;;		    begin ; File.delete(fp2) ; rescue ;; end;;;;;			SYSTEM.writelog("Fileio deleted an old link: "+fp.to_s);;;;;		  else;;;;;		  end		  ;;;;;	    end;;;;;	  end;;;;;	  ;;;;;	  rescue;  #SYSTEM.errorlog("Controller dir cleaner thread rescued an unknown error.");;;;;	  end;;;;;	  sleep 5;;;;;    end;;;;;	begin;  File.delete(@network_directory+"/cleaner.tag");  rescue; SYSTEM.errorlof "Controller cleaner failed to delete tag after thread died."  ;  end;;;;;	}    ;;;;;    ;;;;;  end;;;;;;;;;;  ;;;;;  ;;;;;  def binding;  return @binding;  end;;;;;  ;;;;;  ;;;;;;;;;;  def members?;;;;;    e=Dir.entries(@network_directory)[2..-1];;;;;	if e.length == 0 ;  return [];;;;;	else;;;;;	  l=[];;;;;      e.each do |ee|;;;;;	    p = @network_directory + "/" + ee.to_s;;;;;	    if ee.include?("fileio_link-");;;;;	      l<<ee.split("-")[-1].split(".")[0];;;;;	    end;;;;;	  end;;;;;	  return l;;;;;    end;;;;;  end;;;;;  ;;;;;  def write(inst,str);;;;;    if members?.include?(inst.to_s);;;;;	  fp=@network_directory+"/fileio_input"+inst.to_s+".txt";;;;;	  if File.file?(fp) == true;;;;;	    begin;  File.write(fp,str.to_s); return str.to_s.length;;;;;		rescue;  raise "Controller failed to write file: "+fp.to_s;;;;;		end;;;;;	  else;  raise "Controller fed invalid filepath: "+fp.to_s;;;;;	  end;;;;;	else;  raise "Invalid inst passed.";;;;;	end;;;;;  end;;;;;  ;;;;;  def read(inst);;;;;    fp=@network_directory+"/fileio_output"+inst.to_s+".txt";;;;;	begin; str=File.read(fp);;;;;;	rescue; raise "Controller read failed: "+fp.to_s; str=false;;;;;	File.delete(fp);;;;;	end;;;;;    return str;;;;;  end;;;;;  ;;;;;  def request(inst,str);;;;;    if File.file?(@network_directory+"/fileio_output"+inst.to_s+".txt"); File.delete(@network_directory+"/fileio_output"+inst.to_s+".txt");  end;;;;;    if self.write(inst.to_s,str.to_s).is_a?(Integer);;;;;	  c=0;;;;;	  res = nil;;;;;	  loop do;;;;;	    if c>10;  res=nil;  break;  end;;;;;		if File.file?(@network_directory+"/fileio_output"+inst.to_s+".txt");;;;;		  res=self.read(inst.to_s);;;;;		  break;;;;;		end;;;;;		c+=1;  sleep 1;;;;;	  end;;;;;	  return res;;;;;	else;  raise "Request failed because Controller.write raised a message.";;;;;    end;;;;;  end;;;;;;;;;;  def input(inst);;;;;    if members?.include?(inst.to_s);;;;;	  fp=@network_directory+"/fileio_input"+inst.to_s+".txt";;;;;	  print"\n";  str=gets.chomp;;;;;	  if File.file?(fp) == true;;;;;	    begin;  File.write(fp,str.to_s); return str.to_s.length;;;;;		rescue;  raise "Controller failed to write file: "+fp.to_s;;;;;		end;;;;;	  else;  raise "Controller fed invalid filepath: "+fp.to_s;;;;;	  end;;;;;	else;  raise "Invalid inst passed.";;;;;	end;;;;;  end;;;;;;;;;;;;;;;;;;;;  def writelog(str);;;;;    if str.to_s.length <= 0;  return false;  end;;;;;	if File.file?(@logdir) == false;  f=File.open(@logdir,"w");  f.close;  end;;;;;    ts=Time.now.to_s.split(" ")[0..1].join(".").split(":").join(".").split("-").join(".");;;;;    f=File.open(@cfgpath,"a"); f.write(ts+": "+str.to_s);;;;;	return true;;;;;  end;;;;;;;;;;  def save_config;;;;;    begin;  File.write(@config_data.to_s);;;;;	rescue;  return false;;;;;	end;;;;;	return true;;;;;  end;;;;;  def load_config;;;;;    begin;  @config_data=eval(File.read(@cfgpath));;;;;    rescue;  return false;;;;;    end;;;;;	return true;;;;;  end;;;;;  ;;;;;  def state;  return @controller_state;  end;;;;;;;;;;  def log;  return self.binding.log;  end;;;;;;;;;;  def dir;  return self.binding.dir;  end;;;;;  ;;;;;  ;;;;;;;;;;  class FileIO_Eval_Binder  ## rename to control binding;;;;;    def initialize(dir,mode,log) ## mode: read / eval;;;;;	  ;;;;;      fp=dir.to_s+"/fileio_input"+SYSTEM.instance.id.to_s+".txt";;;;;	  fp2=dir.to_s+"/fileio_output"+SYSTEM.instance.id.to_s+".txt"	 ;;;;;	  ;;;;;	  @dir=dir                                           ##bound dir;;;;;	  @inpath=fp;;;;;	  @outpath=fp2;;;;;	  f=File.open(@inpath,"w");  f.close;;;;;	  ;;;;;	  if mode.to_s=="eval";  @eval_allowed=true; @mode="eval";;;;;	  elsif mode.to_s=="read"; @eval_allowed=false; @mode="read";;;;;	  end;;;;;	  ;;;;;	  @eval_idle_delay=1.0;;;;;	  @eval_delay=0.1;;;;;	  ;;;;;	  @log=true;;;;;	  @private_log=[];;;;;;;;;;	  @name=rand(100000000000).to_s(36);;;;;	  @admin=false   ;;;;;;;;;;      @state='initializing'	  ;;;;;	  @running=false;;;;;	  @thread=nil;;;;;	  @tracker_thread=nil;;;;;;;;;;	  @context=SYSTEM   ##make this an init arg;;;;;	  @buffer=[];;;;;	  ;;;;;	end;;;;;;;;;;    def start;;;;;      if @running;  return false;  end;;;;;      @running=true; @state="active";  @opid=0;;;;;	  ;;;;;	  if @mode=="eval";;;;;	  ;;;;;	  @thread=Thread.new{;;;;;	    loop do;;;;;	      if @running == false;  break;  end;;;;;		  @state="active";;;;;		  if File.file?(@inpath) == true;;;;;            str=File.read(@inpath);;;;;	        ;;;;;				;;;;;			if str.length > 0;;;;;			  File.write(@inpath,"");;;;;			  @buffer<<@opid.to_s+"<< "+str.to_s;;;;;	          if @eval_allowed != true ; sleep @eval_idle_delay;  next ;  end;;;;;			  begin;;;;;			    @state="evaluating";;;;;			    res=@context.instance_eval(str)  ;;;;;			  rescue => e;;;;;			    res = "EXCEPTION::: " + e.to_s + "\n" + e.backtrace.join("\n");;;;;			  end;;;;;			  @state="posting";;;;;			  File.write(@outpath,res.to_s);;;;;			  sleep @eval_delay;;;;;			  @buffer << @opid.to_s+">> "+res.to_s;;;;;			  ;;;;;			  begin;;;;;			  ;;;;;			  if @log==true;;;;;			    s1=SYSTEM.instance.id.to_s+":"+@opid.to_s+":"+Time.stamp;;;;;			    s2="<< "+str.to_s;;;;;				s3=">> "+res.to_s;;;;;				s4=s1+"\n"+s2+"\n"+s3+"\n";;;;;				if File.file?(@dir.to_s+"/log.txt") == false;;;;;				  s5=SYSTEM.instance.id.to_s+":"+@opid.to_s+":"+Time.stamp+": Dir log created. ("+@dir.to_s+")";;;;;				  f=File.open(@dir.to_s+"/log.txt","w");  f.write(s5);  f.close;;;;;				end;;;;;				f=File.open(@dir.to_s+"/log.txt","a");  f.write(s4);  f.close;;;;;				@private_log << s4;;;;;			  end;;;;;			  ;;;;;			  rescue;  SYSTEM.errorlog "Controller eval log write failed.";;;;;			  end;;;;;			  ;;;;;			  @opid += 1;;;;;			  @state="idle";  sleep @eval_idle_delay;;;;;			else; @state="idle"; sleep @eval_idle_delay;;;;;			end;;;;;	      else;  @state="idle";  sleep @eval_idle_delay;;;;;		  end;;;;;		  ;;;;;	    end;;;;;	    @running=false; @state="stopped";;;;;	  };;;;;	  ;;;;;	  end;;;;;	  ;;;;;	  self.spawn_tracker_thread;;;;;      ;;;;;	  return true;;;;;	end;;;;;;;;;;	def spawn_tracker_thread;;;;;	  @tracker_thread=Thread.new{;;;;;	    loop do;;;;;	      if @running==false;;;;;		  else;;;;;		    id=SYSTEM.instance.id.to_s;;;;;            fp=@dir+"/fileio_link-"+id+".txt";;;;;		    f=File.open(fp,"w");  f.write(Time.stamp); f.close ;;;;;		  end;;;;;	      sleep 5.0;;;;;	    end;;;;;	  };;;;;	end;;;;;	;;;;;	;;;;;    def stop;;;;;	  if @running == true;;;;;	    @thread.kill;  @thread=nil;;;;;		@tracker_thread.kill; @tracker_thread=nil;;;;;		@running=false;;;;;		return true;;;;;	  else;  return false;;;;;	  end;;;;;	end;;;;;;;;;;;;;;;    def lock;  @eval_allowed=false;  end;;;;;	def unlock;  @eval_allowed=true;  end;;;;;	def mode *args;;;;;	  if args.length == 0 ;  return @mode;;;;;	  else; @mode = args[0].to_s;;;;;	  end;;;;;	end;;;;;	;;;;;    def dir;  return @dir;  end;;;;;	;;;;;	def log; return @private_log;  end;;;;;  ;;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;end;;;;;;;;;;@controller=nil;;;;;def controller;  return @controller;  end;;;;;alias :con :controller;;;;;;;;;;;;;;;;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/definitions.rb#1#::#1#::#0#::#0#::#0#::#0#::#1##self.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4##;;;;;## ossy7.20;;;;;;;;;;;;;;;## all 256 ascii characters;;;;;CHARS = [] ; c = 0 ; 256.times{ CHARS << c.chr.to_s ; c += 1 };;;;;## every 8 bit binary number in cardinal order;;;;;BINARY = [] ; c = 0 ; 256.times {  b = c.to_s(2) ; until b.to_s.length == 8 ; b = "0" + b.to_s ; end ; BINARY << b ; c += 1 };;;;;## every hexicdeimal number in order;;;;;HEX = [] ; c = 0 ; 256.times { h = c.to_s(16) ; if h.length == 1 ; h = "0" + h.to_s ; end ; HEX << h ; c += 1 };;;;;## a list of all 8 bit byte codes for the ascii characters;;;;;#BYTES = [] ; HEX.each do |h| ; BYTES << "\\x" + h ; end;;;;;##system/region termonology;;;;;DAYS = ["sunday","monday","tuesday","wednesday","thursday","friday","saturday"];;;;;MONTHS = ["january","february","march","april","may","june","july","august","september","october","november","december"];;;;;SEASONS = ["spring","summer","autum","winter"];;;;;;;;;;$CHARS = CHARS;;;;;$BINARY = BINARY;;;;;$HEX = $HEX;;;;;;;;;;TIMEZONES=[""];;;;;COLORS=[] ## color names(only primary colors);;;;;COLORP=[] ## color hex values;;;;;UNITS=[] #(OF METRIC);;;;;UNITSAB=[] #above units abbreviations;;;;;KEYWORDS=[] ## all default ruby syntax keywords plus ossy ones;;;;;EXECPS=[] ## Exception types;;;;;;;;;;;;;;;## some nifty methods for fooling around;;;;;def _and(a,b) ; if a == 1 and b == 1 ; return 1 ; else ; return 0 ; end ; end;;;;;def _or(a,b) ; if a == 0 and b == 1 or a == 1 and b == 0 ; return 1 ; else ; return 0 ; end ; end;;;;;def _not(a,b) ; if a == 0 and b == 0 ; return 1 ; else ; return 0 ; end ; end;;;;;def _nor(a,b) ; if a == 0 and b == 0 or a == 0 and b == 1 or a == 1 and b == 0 ; return 1 ; else ; return 0 ; end ; end;;;;;def _nand(a,b) ; if a == 1 and b == 1 or a == 0 and b == 0 ; return 1 ; else ; return 0 ; end ; end;;;;;def _xor(a,b) ; if a == 0 and b == 1 or a == 1 and b == 0 or a == 1 and b == 1 ; return 1 ; else return 0 ; end ; end;;;;;## random string to compliment random number method;;;;;def rands(*int);if int[0].to_i>=2;t=int[0].to_i;else;t=1;end;s='';t.times{s='';s<<rand(255).chr};return s;end;;;;;## figure out what os the interpreter is on;;;;;;;;;;;;;;;## determine if host is windows, regardless of what it tells the interpreter by actually looking at memory and files;;;;;def windows_host?;if ENV["OS"] == "Windows_NT" and File.directory?("C:/");return true;end;end;;;;;## why in gods name is this not a method or at least alias in Object;;;;;def time;Time.now;end;;;;;def date;;end;;;;;def internet?;;end ## use open uri to attempt to connect to the internet;;;;;;;;;;def bench_mark(str,cont);;;;;  s=Time.now;;;;;  begin;cont.instance_eval(str.to_s);return Time.now-s;;;;;  rescue => e;return "Exception: \n"+e.to_s+"\n"+e.backtrace[0..1].join("\n");;;;;  end;;;;;end;;;;;alias :bm :bench_mark;;;;;;;;;;def eval_input *args;;;;;  estr="{exit}";  lines=[];;;;;  if args.length==1;cont=args[0];  else;  cont=self;  end;;;;;  loop do;;;;;    line=gets.chomp;;;;;	if line.to_s=="{exit}";  break;;;;;	else;  lines << line.to_s;;;;;	end;;;;;  end;;;;;  code=lines.join("\n")+"\n";;;;;  begin;  res = cont.instance_eval(code);;;;;  rescue => e;  res=e.to_s+"\n"+e.backtrace.join("\n");;;;;  end;;;;;  return res;;;;;end;;;;;;;;;;#####################################################################################################################################################################################;;;;;## this stuff is for objects that need their parent class to have a method or alias name, class or other objects;;;;;## basically the stuff you define here is in the context of every class object hereafter;;;;;Object.class_eval{;;;;;  def local_methods ; ms = self.methods ; mets = [] ; ms.each { |m| mets << m.to_s } ; rm = self.class.methods ; self.class.class.methods.each { |m| rm << m.to_s } ; nm = [] ; mets.each { |m| unless rm.include?(m.to_s) ; nm << m.to_s ; end } ; return nm ; end;;;;;  alias :m :methods ; alias :lm :local_methods;;;;;  alias :lv :local_variables ; alias :gv :global_variables ; alias :iv :instance_variables;;;;;  alias :ivs :instance_variable_set ;   alias :ivg :instance_variable_get   ##dont forget get/set constants and classvariables;;;;;  alias :iev :instance_eval ; alias :ev :eval;;;;;  def constants ; MAIN.class.constants ; end ; alias :cn :constants;;;;;};;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##array.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Array redefinition;;;;;# ossy7.20;;;;;# We only add one method so far, a visual of .to_s;;;;;;;;;;Array.class_eval{;;;;;;;;;;  def delete_clones;;;;;    na=[];;;;;	a=self;;;;;	a.each { |i| if na.include?(i) == false ; na << i ; end};;;;;    return na;;;;;  end;;;;;;;;;;  def syntax  ## pretty much the same as Array.class.to_s but now you can read the code :D (some objects need to have support added if you want to use them like Method or Enumurator);;;;;    items = [];;;;;    self.each do |o| ;;;;;      if [Integer,Fixnum,Bignum,Float,Range,Hash].include?(o.class) ; items << o.to_s;;;;;	  elsif o.is_a? String ; items << "\"" + o.to_s + "\"";;;;;	  elsif o.is_a? Symbol ; items << ":" + o.to_s;;;;;	  elsif o == true ; items << "true";;;;;	  elsif o == false ; items << "false";;;;;	  elsif o == nil ; items << "nil";;;;;	  elsif o == [] ; items << "[]";;;;;	  elsif o.is_a?(Symbol) ; items << ":"+o.to_s;;;;;	  elsif o.is_a?(Array) ; items << o.to_s;;;;;	  elsif o.is_a?(Class) ; items << o.inspect.to_s  ## because of this watchout for accidentally pushing classes into arrays instead of the data they were to return;;;;;	    begin;s=o.to_s;;;;;		rescue;s='';;;;;		end;;;;;		items<<s;;;;;      end	  ;;;;;	end;;;;;    "[" + items.join(", ").to_s + "]";;;;;  end;;;;;  ##alias :to_s :syntax  ##use this to hijack Array objects .to_s method;;;;;}#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##bignum.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Bignum redefinition;;;;;# ossy7.20;;;;;# Integers that are also Bignum store their methods here rather than in Integer;;;;;;;;;;##BIGNUM MAY BE DEPRECIATED;;;;;# Bignum.class_eval{;;;;;  # def commas  ##format large numbers with commas;;;;;    # str = "";;;;;    # s = self.to_s.split("").reverse ; i=0;;;;;    # s.each do |nc|;;;;;      # if i == 2;;;;;        # i=0 ; str << nc.to_s + ",";;;;;      # else;;;;;	    # str << nc.to_s ; i+=1 ;;;;;	  # end ;;;;;    # end;;;;;    # if str.to_s[-1].chr.to_s == ",";;;;;  	  # str = str.reverse.to_s.split("")[1..-1].join("").to_s;;;;;    # else;;;;;  	  # str = str.reverse.to_s;;;;;    # end;;;;;    # return str.to_s;;;;;  # end ;;;;;  # alias :com :commas  ## make this crap shorter to type and annoying for linux programmers cause im a dick;;;;;#};;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##database.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4### BRING DEX.RB OVER HERE AND GENERALIZE IT FOR DICTIONARY BUILDING#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##dir.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Dir redefinition;;;;;# ossy7.20;;;;;##;;;;;##  Dir.exist?(String);;;;;##  Dir.image(String);;;;;##  Dir.build_image(String,String);;;;;##  Dir.dir *args;;;;;##  Dir.view *args;;;;;##  Dir.map(String);;;;;##  Dir.size?(String);;;;;##  Dir.empty?(String);;;;;##  Dir.empty!(String);;;;;##  Dir.delete(String)  ##add this already;;;;;##  Dir.search *args;;;;;##  Dir.copy(String,String);;;;;##  Dir.move(String,String);;;;;##  Dir.rename(String,String);;;;;##  Dir.locate *args;;;;;##  Dir.clones?       ##this works different than File.clones?;;;;;##  ;;;;;##;;;;;;;;;;;;;;;Dir.instance_eval{;;;;;;;;;;  def exist? inp ##i cant believe this isnt already a thing what if i just learned ruby and im like oh the exist? method is in Dir;;;;;    File.exist?(inp);;;;;  end;;;;; ;;;;;;;;;;  def image(dir,dest,fname);;;;;    ;;;;;	begin;;;;;	;;;;;	name=dir.to_s.split("/")[-1];;;;;    map=Dir.map(dir.to_s);;;;;	files=map[0];;;;;	dirs=map[1]#.sort_by {|x| x.length} #might depend on order mapped to be validly creatable in list order;;;;;	;;;;;	nd=[];;;;;	dirs.each do |d|;;;;;	  s=d.split("/"+name+"/")[1..-1].join("/"+name+"/");;;;;	  nd<<s;;;;;	end;;;;;	dirs=nd;;;;;	;;;;;	#make string of all dirs;;;;;	datasep="?*?"+"*?";;;;;	dir_tree=dirs.join(datasep);;;;;	;;;;;	##read all the files;;;;;    file_data=[];;;;;	datasep="#4#:::"+"#4#:"+"::#4#:::#4#:::#1#";;;;;	files.each do |f|;;;;;	  fp = f.split("/"+name+"/")[1..-1].join("/"+name+"/")	;;;;;	  ff=File.open(f,"rb");file_data<<[fp,datasep,ff.read].join('');ff.close;;;;;	end;;;;;    ;;;;;	##join all the files;;;;;	datasep="#7#:::"+"#7#:"+"::#7#:::#7#:::#3#";;;;;    file_data=file_data.join(datasep);;;;;	;;;;;	#make final image string;;;;;	datasep=("#1#:::"+"#1#:::#1#:::#1#:::#1#");;;;;    img=file_data+datasep+dir_tree;;;;;	;;;;;	#write image file;;;;;	path=name+"-image-"+fname.to_s+".dim";;;;;	f=File.open(dest+"/"+path,"wb");f.write(img);f.close;;;;;	;;;;;	rescue;return false;;;;;    end;;;;;	;;;;;	return true;;;;;	;;;;;  end;;;;; ;;;;;  def build_image(path,dest);;;;;    if File.file?(path.to_s) and path.to_s.split(".")[-1].downcase=="dim";;;;;      if File.dir?(dest.to_s) ;;;;;		name=path.to_s.split("-image")[0].split("/")[-1];;;;;	    f=File.open(path,"rb");img=f.read;f.close;;;;;        ;;;;;		#split image into filedata and dirs;;;;;	    datasep="#1#:::"+"#1#:::#1#:::#1#:::#1#";;;;;		img=img.split(datasep);;;;;		;;;;;		#split apart directory list;;;;;		file_data=img[0];;;;;		datasep="?*?"+"*?";;;;;		dir_tree=img[1].split(datasep);;;;;		;;;;;        #split files apart;;;;;        datasep="#7#:::"+"#7#:"+"::#7#:::#7#:::#3#";;;;;        files=file_data.split(datasep);;;;;		;;;;;		#split file data and paths from eachother ;;;;;		file_data=[];;;;;		datasep="#4#:::"+"#4#:"+"::#4#:::#4#:::#1#";;;;;		files.each {|f| file_data<< f.split(datasep)};;;;;		;;;;;		$f=file_data;;;;;		;;;;;		#make all dirs;;;;;        path=dest+"/"+name;;;;;		Dir.mkdir(path);;;;;        dir_tree.each do |d|;;;;;		  begin;;;;;		  Dir.mkdir(path+"/"+d);;;;;		  rescue;;;;;		  end;;;;;		end;;;;;		;;;;;		#make all files;;;;;		file_data.each do |fd|;;;;;		  fpath=path+"/"+fd[0];;;;;		  f=File.open(fpath,"wb");f.write(fd[1]);f.close;;;;;		end;;;;;		;;;;;		return true;;;;;	  ;;;;;	  else;raise "Destination directory doesnt exist.!";return false;;;;;	  end;;;;;    else;raise "Method arg[0] must be a dim file.";return false;;;;;    end;;;;;  end ;;;;;;;;;;  def dir *args ## Dir.chdir and Dir.getwd are now in the same method, pass no arguement to get directory and a name of a subdirectory, whole directory or even '..' to change directory ;;;;;    if args.length==0;return Dir.getwd.to_s;;;;;    elsif args[0].is_a?(String);;;;;      if File.directory?(args[0]) ; Dir.chdir(args[0]) ; return Dir.getwd.to_s;;;;;      elsif File.directory?(Dir.getwd.to_s + "/" + args[0].to_s) ; Dir.chdir(Dir.getwd.to_s + "/" + args[0].to_s) ; return Dir.getwd.to_s;;;;;	  else ; raise "No such directory.";;;;;      end;;;;;    end;;;;;  end;;;;;  ;;;;;  def view *args ## prints directory contents to screen;;;;;    if args[0] == nil;;;;;	  dir = Dir.getwd.to_s;;;;;    elsif File.directory?(args[0].to_s);;;;;      dir = args[0].to_s  ;;;;;    elsif File.directory?(Dir.getwd + args[0]);;;;;      dir = Dir.getwd + args[0];;;;;    else;;;;;      dir = false;;;;;    end;;;;;    if dir == false ; raise "No such directory: " + args[0].to_s;;;;;    else ;;;;;	    cont = Dir.entries(dir.to_s) ; cont.delete(".") ; cont.delete("..") ; bt = 0;;;;;		if cont.length == 0 ; return  "Directory is empty" ;;;;;	    else;;;;;		  str = [] ; fi = [] ; fo = [];;;;;		  cont.each do |p|;;;;;		    if File.file?(dir.to_s + "/" + p.to_s);;;;;		              begin ; s = File.size?(dir.to_s + "/" + p.to_s).to_s ; rescue ; s = "" ; end;;;;;			  fi << "File: " + p.to_s + "    Size: " + s.to_s;;;;;		    elsif File.directory?(dir.to_s + "/" + p.to_s);;;;;			  fo << "Dir:  " + p.to_s + "";;;;;			end;;;;;		  end;;;;;		  str << "Directory:   \"" + dir.to_s + "\"   Files: " + fi.length.to_s + ", Folders: " + fo.length.to_s;;;;;		  str << "#############################################";;;;;		  fo.each { |f| str << f.to_s } ; fi.each { |f| str << f.to_s };;;;;		  str << "#############################################\n";;;;;		  puts str.join("\n").to_s;;;;;		end;;;;;    end;;;;;  end;;;;;  ;;;;;  def map(dir);;;;;     if File.directory?(dir.to_s) or File.directory?(Dir.getwd.to_s + "/" + dir.to_s);;;;;      if File.directory?(dir.to_s) ; ; else ; dir = Dir.getwd.to_s + "/" + dir.to_s ; end;;;;;      cur = nil ; rem = [dir.to_s] ; fi = [] ; fo = [] ; ex = [];;;;;      until rem.length == 0;;;;;        cur = rem[0].to_s ; rem.delete_at(0);;;;;        begin ; cont = Dir.entries(cur.to_s) ; cont.delete(".") ; cont.delete("..");;;;;          if cont.length > 0;;;;;             cont.each do |p|;;;;;               if File.file?(cur.to_s + "/" + p.to_s) ; fi << cur.to_s + "/" + p.to_s;;;;;               elsif File.directory?(cur.to_s + "/" + p.to_s) ; fo << cur.to_s + "/" + p.to_s ; rem << fo[-1];;;;;               end;;;;;             end;;;;;          end;;;;;        rescue;;;;;          ex << cur;;;;;        end;;;;;      end;;;;;      if ex.length == 0 ; return [fi,fo];;;;;      else ; return [fi,fo,ex];;;;;      end;;;;;	elsif File.file?(dir.to_s) ; return "Arguement is a file. Dir.map returns arrays of subdirectories and files with in a directory, it does not work on files.";;;;;    else;;;;;      raise "No such directory";;;;;    end;;;;;  end;;;;;  ;;;;;  def size?(dir) ## gets the size of an entire directory;;;;;    if File.directory?(dir);;;;;      m = map(dir);;;;;      if m.length == 2;;;;;        s = m[0].join('').length + m[1].join('').length;;;;;        if m[0].length > 0;;;;;          m[0].each do |f|;;;;;            s += File.size?(f);;;;;          end;;;;;        end;;;;;        return s;;;;;      else;;;;;        raise "Directory can not be measured because it contained unreadable subdirectories: " + m[2].join(", ").to_s;;;;;      end;;;;;	elsif File.file?(dir.to_s) ; return File.size?(dir.to_s);;;;;    else ; raise "No such file or directory.";;;;;    end ;;;;;  end;;;;;  ;;;;;  def empty?(dir);;;;;    if File.directory?(dir) ; if Dir.entries(dir.to_s).length <= 2 ; return true ; else ; return false ; end;;;;;	elsif File.file?(dir) ; return File.empty?(dir.to_s);;;;;	else ; return "No such file or directory.";;;;;	end;;;;;  end;;;;;  ;;;;;  def empty!(dir) # deletes everything in a directory before deleting it;;;;;    failed=[];;;;;    map=Dir.map(dir);;;;;	map[0].each {|f| begin;File.delete(f);rescue;failed<<f;end };;;;;	dirs=map[1].reverse;;;;;    dirs.each do |d|;;;;;	  begin;Dir.delete(d);;;;;	  rescue;failed<<d;;;;;	  end;;;;;	end;;;;;    if failed.length==0;return true;;;;;	else;return failed;;;;;	end;;;;;  end  ;;;;;;;;;;  def delete!(dir);;;;;    if self.empty!(dir);;;;;      Dir.delete(dir);;;;;	  return true;;;;;	else;return false;;;;;	end;;;;;  end;;;;;;;;;;  ;;;;;  ##THIS METHOD NEEDS SOME FUCKING TLC COME ON 20 YEAR OLD JACOB!;;;;;  ## searches for files with a name or contents specified;;;;;  def search *args # dir, tag, filebytes, ignorecase;;;;;    if args[0].is_a?(String) and File.directory?(args[0].to_s);;;;;	  if args[1].to_s.length > 0;;;;;	    found_files = []; found_folders = [] ; found_file_pages = [] ; map = Dir.map(args[0].to_s);;;;;        if map[1].length > 0;;;;;		  map[1].each do |dir|;;;;;		    if args[3] == true ; d = dir.to_s.downcase ; term = args[1].to_s.downcase;;;;;			else ; d = dir.to_s ; term = args[1].to_s;;;;;			end ; if d.to_s.include?(term.to_s) ; found_folders << dir.to_s ; end;;;;;		  end;;;;;		end		;;;;;		if map[0].length < 0;;;;;		  map[0].each do |path|;;;;;		    if args[3] == true ; p = path.to_s.downcase ; term = args[1].to_s.downcase;;;;;			else ; p = path.to_s ; term = args[1].to_s;;;;;			end ; if p.to_s.include?(term.to_s) ; found_files << p.to_s ; end	    ;;;;;			if args[2] == true;;;;;			  fi = File.open(path.to_s,"r") ; cont = fi.read.to_s ; fi.close;;;;;			  if args[3] == true ; cont = cont.to_s.downcase ; term = args[1].to_s.downcase;;;;;			  else ; cont = cont.to_s ; term = args[1].to_s;;;;;			  end;;;;;			  if cont.to_s.include?(term.to_s) ;;;;;			    position = cont.to_s.downcase.split(term.to_s.downcase)[0].to_s.length;;;;;			    found_file_pages << [path.to_s,position.to_i];;;;;			  end;;;;;			end;;;;;		  end		;;;;;		end;;;;;        res = [found_files,found_folders,found_file_pages];;;;;		if args[2] == true ; return res;;;;;		else;;;;;          if res[0].length == 0 and res[1].length == 0 ; return "No instances of the term were found in the given directory.";;;;;		  else ; return res[0..1];;;;;		  end;;;;;		end;;;;;	  else	  ; return "No search term was given.";;;;;	  end;;;;;	elsif File.file?(args[0].to_s);;;;;	  if args[1].to_s.length > 0 ; return File.search(args[0].to_s,args[1].to_s);;;;;	  else ; return "No search term was given.";;;;;      end	  ;;;;;	else ; if args.length == 0 ; return "Enter arguements: (dir, tag)" ; else ; return "No such file or directory." ; end;;;;;	end;;;;;  end;;;;;  ;;;;;  def copy(dir,newdir) ## copy utility;;;;;    if File.directory?(dir);;;;;      if File.directory?(newdir.to_s + "/" + dir.to_s.split("/")[-1].to_s) == false;;;;;	    m = Dir.map(dir.to_s);;;;;		if m == [[],[]];;;;;		  Dir.mkdir(newdir.to_s + "/" + dir.to_s.split("/")[-1].to_s);;;;;		else ; Dir.mkdir(newdir.to_s + "/" + dir.to_s.split("/")[-1].to_s);;;;;		  if m[1].length > 0;;;;;		    m[1].each do |d|;;;;;			  nd = newdir.to_s + "/" + d.to_s.split(dir.to_s)[1].to_s;;;;;			  Dir.mkdir(nd.to_s);;;;;			end;;;;;		  end;;;;;		  if m[0].length > 0;;;;;		    m[0].each do |p|;;;;;			  fi = File.open(p.to_s,"r") ; cont = fi.read.to_s ; fi.close;;;;;			  np = newdir.to_s + "/" + p.to_s.split(dir.to_s)[1].to_s;;;;;			  fi = File.open(np.to_s,"w") ; fi.write(cont.to_s) ; fi.close;;;;;			end;;;;;		  end;;;;;		end;;;;;	    return true;;;;;	  else ; return "Target directory already contains a directory with the same name as the one you're copying.";;;;;	  end;;;;;	else ; return "No such directory.";;;;;	end;;;;;  end;;;;;  ;;;;;  def move(dir,newdir) ## move utility;;;;;    if File.directory?(dir);;;;;      if File.directory?(newdir);;;;;	    if File.directory?(newdir.to_s + "/" + dir.to_s.split("/")[-1].to_s) == false;;;;;		  Dir.mkdir(newdir.to_s + "/" + dir.to_s.split("/")[-1].to_s);;;;;		  img = Dir.img(dir.to_s);;;;;		 if img == [[],[],[]] ; Dir.delete(dir.to_s) ; return true;;;;;		  else;;;;;		    Dir.copy(dir.to_s,newdir.to_s);;;;;		    if img[0].length > 0;;;;;			  img[0].each { |f| File.delete(f.to_s) };;;;;			end;;;;;		    if img[1].length > 0;;;;;			  img[1].each { |d| Dir.delete(d.to_s) };;;;;			end;;;;;			Dir.delete(dir.to_s);;;;;			return true;;;;;		  end;;;;;		else ; return "Cannot move because target directory already exists.";;;;;		end;;;;;	  elsif File.file?(newdir) ; return "Target directory is actually an existing file!";;;;;      else ; return "Target directory does not exist.";;;;;      end	  ;;;;;	elsif File.file?(dir) ; return "Dir.move is for directories only, use File.move for files.";;;;;    else ; return "No such directory.";;;;;	end;;;;;  end;;;;;;;;;;  ## rename utility, this ones a bitch to do efficiently dont expect it anytime soon  ;;;;;  def rename(dir,newname) ;;;;;  ;;;;;  end;;;;;;;;;;;;;;;  ## find a file or folder in directory and return path;;;;;  def locate *args # dir, name;;;;;    if File.directory?(args[0].to_s);;;;;	  found = [];;;;;	  map = Dir.map(args[0].to_s);;;;;	  if map == [[],[]] ; return "The target directory is empty.";;;;;	  else;;;;;	    if map[0].length > 0;;;;;		  map[0].each do |path|;;;;;		    if path.include?(args[1].to_s) ; found << path.to_s ; end;;;;;		  end		  ;;;;;		end;;;;;	    if map[1].length > 0;;;;;		  map[1].each do |dir|;;;;;		    if dir.include?(args[1].to_s) ; found << dir.to_s ; end;;;;;		  end;;;;;		end;;;;;	  end;;;;;	  if found.length == 0 ; return false;;;;;	  else;;;;;	    if found.length == 1 ; return found[0].to_s ; else ; return found ; end;;;;;	  end;;;;;	else ; return "No such directory.";;;;;	end;;;;;  end;;;;;  ;;;;;  ## search a directory for duplicate file data and make a list of paths if found;;;;;  ## i dont think ive ever tested this pretty sure its broken;;;;;  def clones? *args # dir;;;;;    if File.directory?(args[0].to_s);;;;;	  m = Dir.map(args[0].to_s);;;;;	  if m == [[],[]] ; return "Target directory is empty.";;;;;      else;;;;;		dat = [] ; m[0].each { |f| dat << File.read(f).to_s };;;;;		same = [];;;;;		until dat.length == 0;;;;;		  obj = dat[0].to_s ; dat.delete_at[0] ; path = m[0] ; m.delete_at(0);;;;;		  if dat.include?(obj.to_s);;;;;		    same << path.to_s;;;;;		    same << m[dat.index(obj.to_s)].to_s;;;;;            m[0].delete_at(dat.index(obj.to_s));;;;;            dat.delete_at(dat.index(obj.to_s));;;;;		  end		;;;;;		end;;;;;		if same.length == 0 ; return false;;;;;		else ; return same;;;;;		end;;;;;      end	  ;;;;;	else ; return "No such directory.";;;;;	end;;;;;  end;;;;;   ;;;;;;;;;;  alias :make :mkdir;;;;;};;;;;;;;;;##this is the same context as self but self is usually defined first and these depend on this class so they have to be after it;;;;;def dir *args ; Dir.dir *args ; end;;;;;def viewdir *args ; puts Dir.view *args ; end;;;;;alias :vd :viewdir;;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##file.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## File redefinition;;;;;# ossy7.20;;;;;;;;;;# File.make(String path);;;;;# File.print(String path);;;;;# File.view(String path);;;;;# File.prepend(String path,String string);;;;;# File.append(String path, String string);;;;;# File.insert(String apth, Integer pos, String string);;;;;# File.read_line(String path, Integer/Range line);;;;;# File.write_line(String path, Integer line, String string);;;;;# File.insert_line(String path, Integer line, String string);;;;;# File.get_lines(String path);;;;;# File.delete_line(String path, Integer line);;;;;# File.include?(String path, String string);;;;;# File.empty?(String path);;;;;# File.empty!(String path);;;;;# File.size?(String path);;;;;# File.copy(String path, String newpath);;;;;# File.move(String path, String newpath);;;;;# File.dir?(String path);;;;;# File.file?(String path);;;;;# File.open(String path, String method);;;;;# File.read(String path);;;;;# File.write(String path, String string);;;;;# File.close;;;;;;;;;;;;;;;File.instance_eval{;;;;;  #def read(path) ; ; end ## ossy hasnt actually had a good reason to redefine read for a long time now this is about to be removed;;;;;  #plus the problem is when you open a file its class has a read method as instance instead of global class so;;;;; #figure that shit out before we reinclude read and write/print;;;;;;;;;;  def make(path);f=File.open(path,"wb");f.close;return true;end;;;;;;;;;;  def print(path)  ## print file to screen;;;;;	unless File.file?(path)==false;;;;;	  print File.read(path);;;;;	end;;;;;  end;;;;;  ;;;;;  def view(path);;;;;    unless File.file?(path)==false;;;;;      puts File.read(path);;;;;	end;;;;;  end;;;;;  ;;;;;  def prepend(path,string);;;;;    ;;;;;  end;;;;;  ;;;;;  ## eliminates the need to open files in "a" mode but problematic for massive file.;;;;;  def append *args # path, str;;;;;    if File.file?(args[0].to_s);;;;;	  if args[1].to_s.length > 0;;;;;	    fi = File.open(args[0].to_s,"r") ; cont = fi.read.to_s ; fi.close;;;;;		fi = File.open(args[0].to_s,"w") ; fi.write(cont.to_s + args[1].to_s) ; fi.close;;;;;	    return true;;;;;	  else ; return "No input string to append to file.";;;;;	  end;;;;;	else ; return "No such file.";;;;;	end;;;;;  end;;;;;  ;;;;;  ## insert string at given character index position (0=first character);;;;;  def insert *args # path, pos, str;;;;;    if File.file?(args[0].to_s);;;;;	  if args[1].is_a?(Integer);;;;;	    fi = File.open(args[0].to_s,"r") ; cont = fi.read.to_s ; fi.close;;;;;		cont = cont.split('');;;;;        inserted = cont[0..args[1].to_i].join('').to_s + args[2].to_s + cont[(args[1].to_i+1)..-1].join('');;;;;		fi = File.open(args[0].to_s,"w") ; fi.write(inserted.to_s) ; fi.close;;;;;		return true;;;;;	  else ; return "Specified position is not a valid integer.";;;;;	  end;;;;;	else ; return "No such file.";;;;;	end;;;;;  end;;;;;;;;;;  # get a paticular line from a file in one call, line can be an integer or valid range of line index numbers;;;;;  def read_line *args # path, line;;;;;    if File.file?(args[0].to_s);;;;;	  fi = File.open(args[0].to_s,"r") ; lines = fi.read.to_s.split("\n") ; fi.close ; lines.delete("");;;;;      if lines.length > 0;;;;;        if args[1].is_a?(Integer) or args[1].is_a?(Range);;;;;		  if args[1].is_a?(Integer);;;;;            return line[args[1].to_i].to_s;;;;;          elsif args[1].is_a?(Range) ;;;;;		    return lines[args[1]].join("\n").to_s;;;;;		  end;;;;;		else ; return "Invalid line index given.";;;;;		end;;;;;      else ; return "File is empty so there were no lines to retrieve.";;;;;      end;;;;;	else ; return "No such file.";;;;;	end;;;;;  end;;;;;  ;;;;;  #write over a paticular line or lines, like above pos can be a range;;;;;  def write_line *args # path, line, string;;;;;    if File.file?(args[0].to_s);;;;;	  if args[1].is_a?(Integer) or args[1].is_a?(Range);;;;;	    if args[2].is_a?(String) and args[2].to_s.length >= 1;;;;;		  fi = File.open(args[0].to_s,"r") ; cont = file.read.to_s.split("\n") ; fi.close;;;;;		  cont[args[1]] = args[2].to_s;;;;;		  fi = File.open(args[0].to_s,"w") ; fi.write(cont.join("\n").to_s) ; fi.close;;;;;		  return true;;;;;		else ; return "No input string to write on line.";;;;;		end;;;;;	  else ; return "Invalid Line specification.";;;;;	  end;;;;;	else ; return "No such file.";;;;;	end;;;;;  end;;;;;  ;;;;;  ##inserts a line at one or more lines, line breaks not allowed..i think...?;;;;;  def insert_line *args # path, line, str;;;;;    if File.file?(args[0].to_s);;;;;	  if args[1].is_a?(Integer) or args[1].is_a?(Range);;;;;	    if args[2].is_a?(String) and args[2].to_s.length >= 1;;;;;		  fi = File.open(args[0].to_s,"r") ; cont = file.read.to_s.split("\n") ; fi.close;;;;;		  d = cont[0..args[1].to_i] ; d << args[2].to_s;;;;;		  #cont[(args[1].to_i+1)..-1].each do |l| ; { d << l } ; end;;;;;		  fi = File.open(args[0].to_s,"w") ; fi.write(d.join("\n").to_s) ; fi.close;;;;;		  return true;;;;;		else ; return "No input string to write on line.";;;;;		end;;;;;	  else ; return "Invalid Line specification.";;;;;	  end;;;;;	else ; return "No such file.";;;;;	end;;;;;  end;;;;;  ;;;;;  ## deletes a line FUCK ADD RANGE SUPPORT;;;;;  def delete_line *args # path, line;;;;;    if File.file?(args[0].to_s);;;;;	  if args[1].is_a?(Integer);;;;;        fi = File.open(args[0].to_s,"r") ; lines = fi.read.to_s.split("\n") ; fi.close;;;;;		lines.delete_at(args[1]);;;;;        fi = File.open(args[0].to_s,"w") ; fi.write(lines.join("\n").to_s) ; fi.close;;;;;		return true;;;;;	  else ; return "Invalid line specification, please enter an integer.";;;;;	  end;;;;;	else ; return "No such file.";;;;;	end;;;;;  end;;;;;  ;;;;;  ## just get all the lines in a file as an array;;;;;  def get_line *args # path;;;;;    if File.file?(args[0].to_s) ; fi = File.open(args[0].to_s,"r") ; cont = fi.read.to_s.split("\n") ; fi.close ; return cont;;;;;	elsif File.directory?(args[0].to_s) ; return "Input string is a directory, File.get_lines only works on files.";;;;;    else ; return "No such file.";;;;;    end  ;;;;;  end;;;;;  ;;;;;  ##works like String.include? but the String is a File instead;;;;;  def include? *args;;;;;    if File.file?(args[0].to_s);;;;;	  if args[1].to_s.length > 0 ; fi = File.open(args[0].to_s) ; cont = fi.read.to_s ; fi.close ; return cont.to_s.include?(args[1].to_s);;;;;	  else ; return "No input string.";;;;;	  end;;;;;	elsif File.directory?(args[0].to_s) ; return "File.include? is for files, not directories.";;;;;	else ; return "No such file.";;;;;    end;;;;;  end;;;;;  ;;;;;  ##delete file contents;;;;;  def empty!(path);;;;;    if File.file?(path.to_s);;;;;	  if File.size?(path.to_s) > 0 ; fi = File.open(path.to_s,"w") ; fi.write('') ; fi.close ; return true;;;;;	  else ; return "File is already empty.";;;;;	  end;;;;;	elsif File.directory?(path.to_s) ; return "File.empty! is for files, not directories, use Dir.empty! if you want to delete all the contents of a directory.";;;;;	else ; return "No such file.";;;;;    end    ;;;;;  end;;;;;  ;;;;;  ## true if file size 0;;;;;  def empty?(path);;;;;    if File.file?(path.to_s);;;;;	  fi = File.open(path.to_s,"r") ; cont = fi.read.to_s.split('').length ; fi.close;;;;;	  if cont == 0 ; return true ; else ; return false ; end;;;;;	elsif File.directory?(path.to_s) ; return "File.empty? is for files, use Dir.empty for directories.";;;;;    else ; return "No such file.";;;;;    end    ;;;;;  end;;;;;  ;;;;;   #def size?(path);;;;;   #  f=File.open(path,"rb");size=f.read.to_s.split('').length;f.close;return size;;;;;   #end;;;;;  ;;;;;  ## copy utility;;;;;  def copy *args #path, newpath;;;;;    if File.file?(args[0].to_s);;;;;	  if File.directory?(args[1].to_s);;;;;	    if File.file?(args[1].to_s + "/" + args[0].to_s.split("/")[-1].to_s) == false;;;;;	      fi = File.open(args[0].to_s,"rb") ; cont = fi.read.to_s ; fi.close;;;;;		  fi = File.open(args[1].to_s + "/" + args[0].to_s.split("/")[-1].to_s,"wb") ; fi.write(cont.to_s) ; fi.close;;;;;          return true		  ;;;;;		else ; return "Target directory already contains a file with the same name.";;;;;		end;;;;;	  else ; return "Input target directory is invalid.";;;;;	  end;;;;;	else ; return "No such file.";;;;;	end  ;;;;;  end;;;;;  ;;;;;  #move utility;;;;;  def move *args #path, newpath;;;;;    if File.file?(args[0].to_s);;;;;	  if File.directory?(args[1].to_s);;;;;	    if File.file?(args[1].to_s + "/" + args[0].to_s.split("/")[-1].to_s) == false;;;;;	      fi = File.open(args[0].to_s,"rb") ; cont = fi.read.to_s ; fi.close;;;;;		  fi = File.open(args[1].to_s + "/" + args[0].to_s.split("/")[-1].to_s,"wb") ; fi.write(cont.to_s) ; fi.close;;;;;		  File.delete(args[0].to_s);;;;;          return true		  ;;;;;		else ; return "Target directory already contains a file with the same name.";;;;;		end;;;;;	  else ; return "Input target directory is invalid.";;;;;	  end;;;;;	else ; return "No such file.";;;;;	end  ;;;;;  end ;;;;;  ;;;;;  alias :dir? :directory?;;;;;};;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##fixnum.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Fixnum redefinition;;;;;# ossy7.20;;;;;# Integers that are fixnum store their methods here rather than Integer;;;;;;;;;;# Fixnum.class_eval{;;;;;  # def commas  ##format large numbers with commas;;;;;    # str = "";;;;;    # s = self.to_s.split("").reverse ; i=0;;;;;    # s.each do |nc|;;;;;      # if i == 2;;;;;        # i=0 ; str << nc.to_s + ",";;;;;      # else;;;;;	    # str << nc.to_s ; i+=1 ;;;;;	  # end ;;;;;    # end;;;;;    # if str.to_s[-1].chr.to_s == ",";;;;;  	  # str = str.reverse.to_s.split("")[1..-1].join("").to_s;;;;;    # else;;;;;	  # str = str.reverse.to_s;;;;;    # end;;;;;    # return str.to_s;;;;;  # end;;;;;  ;;;;;  # alias :com :commas ## make this crap shorter to type and annoying for linux programmers cause im a dick;;;;;# };;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##integer.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Integer redefinition;;;;;# ossy7.20;;;;;# Here we add exponate, factors and prime? which ruby should already have a dozen such methods out of the box if you ask me;;;;;;;;;;Integer.class_eval{;;;;;;;;;;  def exponate ## manually search for the exponate form of the integer;;;;;    n = self ; c=2 ; e=2 ; r = [0,0];;;;;    until c > n.to_i;;;;;      e = 2;;;;;      until e >= n.to_i ; if c**e == n.to_i ; return [c,e] ; end ; e += 1 ; end;;;;;      c += 1;;;;;    end;;;;;  end;;;;;  ;;;;;  def factors ## manually search for the factors of the integer and return the first one found;;;;;    n = self ; p = [2] ; vn = 2;;;;;    until vn == n;;;;;      vn += 1;;;;;      p << vn;;;;;    end;;;;;    p.delete_at(-1);;;;;    f1 = 0 ; f2 = 0 ; pd = [];;;;;    p.each { |pn| ;;;;;      s = n.to_f / pn.to_f;;;;;      if s.to_s[-2..-1].to_s == ".0";;;;;        pd << pn;;;;;      end;;;;;    };;;;;    pd.each { |p|;;;;;      if p * p == n;;;;;        f1, f2 = p, p;;;;;      else;;;;;        cd = pd;;;;;        cd.delete(p);;;;;        cd.each { |pr| ;;;;;          if p * pr == n;;;;;            f1, f2 = p, pr;;;;;            break;;;;;          end ;;;;;        };;;;;      end;;;;;    };;;;;    [f1,f2];;;;;  end;;;;;  ;;;;;  def prime? ## manually check all the numbers below a number to see if only one and its self divide with out remainder.;;;;;    n=self;;;;;    rv=true;c=1;l=self-1 ;;;;;    until c>=l;;;;;      c+=1;;;;;      if (self.to_f/c.to_f).to_s.split(".")[-1].to_i==0;;;;;        rv=false;c=self;;;;;      end    ;;;;;    end;;;;;    rv;;;;;  end  ;;;;;  ;;;;;  def surname;;;;;    int=self.to_s	;;;;;	if int.to_s=="0";int="0";;;;;	elsif int[-2..-1]=="11" or int[-2..-1] =="12" or int[-2..-1] =="13";;;;;	  int<<"th";;;;;    elsif int[-1]=="1";int<<"st";;;;;    elsif int[-1]=="2";int<<"nd";;;;;    elsif int[-1]=="3";int<<"rd";;;;;	else;int<<"th";;;;;	end;;;;;    return int;;;;;  end;;;;;  ;;;;;  def commas  ##format large numbers with commas;;;;;    str = "";;;;;    s = self.to_s.split("").reverse ; i=0;;;;;    s.each do |nc|;;;;;      if i == 2;;;;;        i=0 ; str << nc.to_s + ",";;;;;      else;;;;;	    str << nc.to_s ; i+=1 ;;;;;	  end ;;;;;    end;;;;;    if str.to_s[-1].chr.to_s == ",";;;;;  	  str = str.reverse.to_s.split("")[1..-1].join("").to_s;;;;;    else;;;;;  	  str = str.reverse.to_s;;;;;    end;;;;;    return str.to_s;;;;;  end;;;;;;;;;;};;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##log.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Log class definition;;;;;# ossy 5;;;;;# useful log object can link to an output file or just store entries internally;;;;;;;;;;class Log;;;;;  def initialize *args;;;;;    @log=[];@log_creation=Time.now;;;;;    if File.file?(args[0].to_s);;;;;	  @path=args[0].to_s;;;;;	else;;;;;	  @path=nil;;;;;	end;;;;;  end;;;;;  def write str;;;;;    @log<<Time.now.to_s+": "+str.to_s;;;;;	if @path!=nil;;;;;	  f=File.open(@path,"a");;;;;	  f.write(Time.now.to_s+": "+str.to_s);;;;;	  f.close;;;;;	end;;;;;  end	;;;;;  def read;;;;;    return @log;;;;;  end;;;;;  def clear;;;;;    @log=[];;;;;  end;;;;;  def size?;;;;;    return @log.length;;;;;  end;;;;;  alias :w :write;;;;;  alias :r :read;;;;;  alias :clr :clear;;;;;end;;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##password.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Password class definition;;;;;# ossy 5;;;;;# THIS IS NOT SECURE IN ANY WAY AND JUST TO OBFUSCATE strings from a user.;;;;;;;;;;class Password;;;;;  def initialize *args;;;;;    if args[0].is_a?(String) and args[0].to_s.length > 0 and args[0].to_s.delete("abcdefghijklmnopqrstuvwxyz0123456789").empty?;;;;;	  @password = args[0].to_s.to_i(36).to_s(2) ## store the password in encoded form;;;;;	else ; raise "Enter a string with only letters and numbers.";;;;;	end;;;;;  end;;;;;  ;;;;;  ##encode some input and see if it matches the encoded password;;;;;  def verify(password) ; if password.to_s.to_i(36).to_s(2) == @password ; return true ; else return false ; end ; end;;;;;  ;;;;;  ## if you want the first level of security this class should deligate password changes;;;;;  def change npass;;;;;    @password = npass.to_s.to_i(36).to_s(2);;;;;  end;;;;;  ;;;;;  # get/set encoded form of the password;;;;;  def get ; return @password ; end;;;;;  def set(pw) ; @password = pw ; end;;;;;end;;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##shadow.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4##8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##shell.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Shell class definition;;;;;# ossy 5;;;;;# For programs that want to work like irb;;;;;;;;;;class Shell;;;;;  def initialize;;;;;	@context=nil;;;;;	@cid=nil;;;;;	puts "Welcome to the shell...";;;;;  end;;;;;  def start;;;;;    @main_loop=true;@cid=0;@context=$main;;;;;	while @main_loop   ########################;;;;;	  print @context.class.to_s+":"+@cid.to_s+"<< ";;;;;	  @input = gets.chomp;res=nil;;;;;	  if @input == "exit";@main_loop=false;res="Exiting shell.";;;;;	  #elsif @input == "";;;;;	  #elsif @input == "";;;;;	  else;;;;;	    begin;;;;;	      res = @context.instance_eval(@input);;;;;		rescue => e;;;;;		  res = "Input caused an exception.\n"+e.to_s+"\n"+e.backtrace.join("\n");;;;;		end;;;;;	  end;;;;;	  print @context.class.to_s+":"+@cid.to_s+">> "+res.to_s+"\n";;;;;	  @cid+=1;;;;;	end##this is the end of the loop ##########;;;;;  end;;;;;  ;;;;;end#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##string.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## String redefinition;;;;;# ossy 7.20;;;;;# Here we add many useful methods to string class;;;;;;;;;;String.class_eval{;;;;;  def shuffle ; return self.split('').shuffle.join('').to_s ; end;;;;;  alias :scramble :shuffle;;;;;  def base10? ; self.delete("0123456789").empty? ; end;;;;;  alias :only_numbers? :base10?;;;;;  def base16? ; self.upcase.delete("0123456789ABCDEF").empty? ; end;;;;;  alias :only_hex? :base16?;;;;;  def base36? ; self.upcase.delete("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ").empty? ; end;;;;;  def only_letters? ; self.upcase.delete("ABCDEFGHIJKLMNOPQRSTUVWXYZ").empty? ; end  ;;;;;  def to_binary ##returns a list of the binary byte form of the string from utf8 only(cause ruby);;;;;    b = [] ; s = self.to_s.split('');;;;;	s.each do |ch|;;;;;	  b << BINARY[CHARS.index(ch.to_s)]	;;;;;	end;;;;;	return b.join.to_s;;;;;  end;;;;;  def from_binary ## works on strings used with .to_b restoring them to ascii characters;;;;;    bytes = [] ; s = self.to_s;;;;;	until s.to_s.length == 0;;;;;	  b = s[0..7].to_s ; s = s[8..-1];;;;;	  bytes << b.to_s;;;;;	end;;;;;	str = '';;;;;	bytes.each do |b|;;;;;      str << CHARS[BINARY.index(b.to_s).to_i].to_s;;;;;	end;;;;;	return str.to_s;;;;;  end ;;;;;};;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##time.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Time redefinition;;;;;# ossy7.20;;;;;# Add some methods time needs;;;;;;;;;;Time.class.class.class_eval{;;;;;  def parse_seconds(s) ## take a number of second and compound it into a total of days hours minutes and seconds for timer displays and Time arithmetic;;;;;    s = s.to_s.to_f;;;;;	if s.to_f < 60.0;;;;;	  [0,0,s.to_i];;;;;	elsif s.to_f < 3600.0 and s.to_f >= 60.0;;;;;	  minutes = s.to_f / 60.0;;;;;	  sec = ("." + minutes.to_s.split(".")[-1].to_s).to_f * 60  ## the period is because the expression is converting integers to strings to floats;;;;;	  [0,minutes.to_i, sec.round];;;;;	elsif s.to_f < 86400.0 and s.to_f >= 3600.0;;;;;	  hours = s.to_f / 60.0 / 60.0;;;;;	  minutes = ("." + hours.to_s.split(".")[-1].to_s).to_f * 60;;;;;	  sec = ("." + minutes.to_s.split(".")[-1].to_s).to_f * 60;;;;;	  [hours.to_i, minutes.to_i ,sec.to_i];;;;;    elsif s.to_f >= 86400.0;;;;;	  days = s.to_f / 60.0 / 60.0 / 24.0;;;;;	  hours = ("."+ days.to_s.split(".")[-1]).to_f * 24;;;;;	  minutes = ("." + hours.to_s.split(".")[-1]).to_s.to_i*60;;;;;	  sec = (s/60.0).to_s.split(".")[-1].to_i*60;;;;;	  [days,hours.to_i,minutes,sec];;;;;	end;;;;;  end  ;;;;;;;;;;  def stamp *args ##get a timestamp either from current time or given time object, and convert the two back and fourth by passing them as arguements;;;;;    if args[0] == nil ; t = Time.now ; y = t.year.to_s ; mo = t.month.to_s ; d = t.day.to_s ; h = t.hour.to_s ; mi = t.min.to_s ; s = t.sec.to_s ; if y.length < 4 ; until y.length == 4 ; y = "0" + y ; end ; end ; y = y[0..3] ; 	if mo.length < 2 ; mo = "0" + mo end ; mo = mo[0..1] ; if d.length < 2 ; d = "0" + d ; end ; d = d[0..1] ; if h.length < 2 ; h = "0" + h ; end ; h = h[0..1] ; if mi.length < 2 ; mi = "0" + mi ; end ; mi = mi[0..1] ; if s.length < 2 ; s = "0" + s ; end ; s = s[0..1] ; [y,mo,d,h,mi,s].join(".");;;;;    elsif args[0].is_a? Time ; t = args[0] ; y = t.year.to_s ; mo = t.month.to_s ; da = t.day.to_s ; hr = t.hour.to_s ; mi = t.min.to_s ; se = t.sec.to_s ; if mo.length == 1 ; mo = "0" + mo.to_s ; end ; 	if da.length == 1 ; da = "0" + da.to_s ; end ; if hr.length == 1 ; hr = "0" + hr.to_s ; end ; 	if mi.length == 1 ; mi = "0" + mi.to_s ; end ; if se.length == 1 ; se = "0" + se.to_s ; end ; return y.to_s + "." + mo.to_s + "." + da.to_s + "." + hr.to_s + "." + mi.to_s + "." + se.to_s    	;;;;;    elsif args[0].is_a? String ; t = args[0].split(".") ; return Time.new(t[0],t[1],t[2],t[3],t[4],t[5]);;;;;    end;;;;;  end;;;;;};;;;;#8#;#3#;#5#;#3#;#1#;#8#;#3#;#5#;#3#;#8#;#5##timer.rb#5#;#6#;#9#;#9#;#4#;#5#;#6#;#7#;#9#;#6#;#4## Timer class definition;;;;;# ---;;;;;# Undecided on new timer to stick with putting that off while i focus on more important bug fixes and development#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/dictionary.rb#1#::#1#::#0#::#0#::#0#::#0#::#1###;;;;;## make search load banks in a second slot instead of unloading current bank when searching other banks, then just;;;;;## unload the second bank and no more saving the current bank every time you search;;;;;;;;;;;;;;;class Dictionary;;;;;  def initialize *args;;;;;    #ensure dictionary has an appdata directory  ;;;;;    @logpath=SYSTEM.logdir+"/dictionary.log";;;;;    writelog("Dictionary is initializing. "+self.to_s);;;;;	;;;;;	@appdatadir=SYSTEM.appdatadir+"/dictionary";;;;;	if File.directory?(@appdatadir)==false;Dir.mkdir(@appdatadir);end;;;;;	;;;;;	@cfgpath=@appdatadir+"/config.txt";;;;;	@default_config=["99999","0","database"];;;;;	@config=@default_config;;;;;	if File.file?(@cfgpath)==false; self.save_config ; else;  self.load_config;  end;;;;;	;;;;;	@defbankdir=@appdatadir+"/"+@default_config[2].to_s;;;;;	if File.dir?(@defbankdir)==false; Dir.mkdir(@defbankdir);  end;;;;;	;;;;;	;;;;;	@bankdir=@appdatadir+"/"+@config[2].to_s;;;;;	;;;;;	@bank=[];;;;;	@sbank=[]            ## search slot;;;;;	@banks=[];;;;;    @index=0;;;;;	@bank_load_length=0;;;;;	;;;;;	if args.length == 0;;;;;	  #self.load_dictionary(@config[2].to_s);;;;;	elsif args[0].to_s.length>0;;;;;	  self.load_dictionary(args[0].to_s);;;;;	else;;;;;	  return false  ;;;;;	end;;;;;	;;;;;  end;;;;; ;;;;;  def load_config;;;;;    begin;;;;;	  if File.file?(@cfgpath);;;;;	    f=File.open(@cfgpath,"r");  @config=f.read.split("\n");;;;;	    return true;;;;;	  else; return false;;;;;	  end;;;;;	rescue; raise "Load config failed, file not accessible.";;;;;	end;;;;;  end;;;;;  ;;;;;  def save_config;;;;;    begin; f=File.open(@cfgpath,"w");  f.write(@config.join("\n"));  f.close; return true;;;;;	rescue; raise "Failed to access cfg file.";;;;;	end;;;;;  end;;;;; ;;;;;  def load_dictionary(name);;;;;    if File.directory?(@appdatadir+"/"+name.to_s);;;;;	  @bankdir=@appdatadir+"/"+name.to_s;;;;;	  @bank=[];;;;;	  @banks=[];;;;;      @index=0;;;;;	  @bank_load_length=0;;;;;      self.load_open_bank;;;;;    else; return false;;;;;	end;;;;;  end;;;;;  ;;;;;  def create_dictionary(name);;;;;    if File.dir?(@appdatadir+"/"+name.to_s)==false;;;;;	  Dir.mkdir(@appdatadir+"/"+name.to_s);;;;;	  @bankdir=@appdatadir+"/"+name.to_s;;;;;	  @bank=[];;;;;	  @banks=[];;;;;      @index=0;;;;;	  @bank_load_length=0;;;;;      self.load_open_bank;;;;;	else; return false;;;;;	end;;;;;  end;;;;;  ;;;;;  def delete_dictionary(name);;;;;  ;;;;;  end;;;;;  ;;;;;  def dictionary?; return @bankdir.to_s.split("/")[-1].to_s;  end;;;;; ;;;;;  def dictionary_size?(name);  return Dir.entries(@appdatadir+"/"+name.to_s)[2..-1].length;  end;;;;;  ;;;;;  def dictionary_total_size?(name);;;;;    bytes=0;;;;;    Dir.entries(@appdatadir+"/"+name.to_s)[2..-1].each { |f|;;;;;	  begin;s=File.size?(@appdatadir+"/"+name.to_s+"/"+f.to_s);bytes+=s.to_i;;;;;	  rescue;;;;;	  end;;;;;	};;;;;	return bytes;;;;;  end;;;;;  ;;;;;  def get_dictionaries;;;;;    dics=[];;;;;	Dir.entries(@appdatadir)[2..-1].each { |d| if File.dir?(@appdatadir+"/"+d.to_s);  dics<< d.to_s; end };;;;;	return dics;;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  def grab_shell;;;;;    SYSTEM.shell.start(self);;;;;  end  ;;;;;   ;;;;;   def index;return @index;end;;;;;   def bank;return @bank;end;;;;; ;;;;; ;;;;;  def load_open_bank;;;;;    #get list of banks;;;;;    @banks=[];;;;;    Dir.entries(@bankdir)[2..-1].sort.each { |i| @banks<<i.split(".dat")[0].to_i };;;;;;;;;;    if @banks.length==0  ## no bank data, create empty bank 0;;;;;	  f=File.open(@bankdir+"/0.dat","w");f.close;;;;;	  @index=0;;;;;	  @bank=[];;;;;	  @banks=[0];;;;;	  @bank_load_length=0;;;;;	  writelog("No data bank existed, created bank 0 and loaded it.");;;;;	else  ## bank files exist;;;;;	;;;;;	  if self.bank_size?(@banks[-1])<@config[0].to_i  ## last bank is open;;;;;		writelog("Open bank found:"+@index.to_s);;;;;		self.load_bank(@banks[-1]);;;;;	  else                                       ## last bank full, create new one;;;;;		@banks<<@banks[-1]+1;;;;;		@index=@banks[-1];;;;;		f=File.open(@bankdir+"/"+@index.to_s+".dat","w");f.close;;;;;		@bank=[];;;;;		@bank_load_length=0;;;;;		writelog("Last bank was full, created a new one and loaded it.");;;;;	  end;;;;;	  ;;;;;    end;;;;;    return @index;;;;;  end;;;;;  ;;;;;;;;;;    ##so other methods dont have to implement the same code;;;;;  def load_bank(index);;;;;    path=@bankdir+"/"+index.to_s+".dat";;;;;    if File.file?(path);;;;;	  @bank=[];;;;;	  File.read(path).split("\n").each do |line|;;;;;	    @bank<< eval(line);;;;;	  end;;;;;      @index=index.to_i;;;;;	  @bank_load_length=@bank.length;;;;;	  writelog("Bank "+@index.to_s+" was loaded. Size: "+@bank.length.to_s);;;;;	  return true;;;;;	else;return false;;;;;    end;;;;;  end;;;;;  ;;;;;  ;;;;;  def save_bank;;;;;    bank=[];;;;;    @bank.each {|i| bank<<i.to_s };;;;;	bank=bank.sort;;;;;	f=File.open(@bankdir+"/"+@index.to_s+".dat","w");f.write(bank.join("\n"));f.close;;;;;	@bank_load_length=@bank.length;;;;;	writelog("Bank "+@index.to_s+" was saved. Size: "+@bank.length.to_s);;;;;	return true;;;;;  end  ;;;;;  ;;;;;;;;;;  ##make it able to take no arg and apply to current;;;;;  def bank_size?(index);;;;;    if index.to_i==@index;return @bank.length;;;;;	elsif File.file?(@bankdir+"/"+index.to_s+".dat");;;;;	  l=@bank.length;unloaded=false;;;;;	  if l>0 and l!=@bank_load_length;;;;;	    writelog("Unloading current bank "+@index.to_s+" for a size check on bank "+index.to_s);;;;;	    save_bank;@bank=[];unloaded=true;;;;;	  elsif l>0;;;;;	    writelog("Unloading current bank "+@index.to_s+" for a size check on bank "+index.to_s);;;;;	    @bank=[];unloaded=true;;;;;	  end;;;;;	  size=File.read(@bankdir+"/"+index.to_s+".dat").split("\n").length;;;;;	  if unloaded;;;;;	    load_bank(@index);;;;;	  end;;;;;	  return size;;;;;	else;return false;;;;;	end;;;;;  end;;;;;  ;;;;;  ;;;;;  ## returns bank number and index in an array if found, false if not;;;;;  def search(name);;;;;    writelog("Search operation begun for tag: "+name.to_s+". Searching current bank "+@index.to_s+".");;;;;    found=false;;;;;    @bank.each { |i| if i[0].to_s.downcase==name.to_s.downcase;found=[@index,@bank.index(i)];end};;;;;	;;;;;	if found == false;;;;;	  ;;;;;      ##unload current bank so we dont have more than one bank in memory at a  time;;;;;	  unloaded=false;l=@bank.length;;;;;	  if l>0 and l!=@bank_load_length;;;;;	    writelog("Unloading current bank "+@index.to_s+" to search other banks.");;;;;	    save_bank;@bank=[];unloaded=true;;;;;      elsif l>0;;;;;	    @bank=[];unloaded=true;;;;;	    writelog("Unloading current bank "+@index.to_s+" to search other banks.");;;;;	  end;;;;;	  ;;;;;	  ##search the banks that were not loaded;;;;;	  banks=[];;;;;	  Dir.entries(@bankdir)[2..-1].sort.each { |i| banks<<i.split(".dat")[0].to_i };;;;;      banks.delete(@index);;;;;	  banks.each do |b|;;;;;	    writelog("Searching bank "+b.to_s+".");;;;;	    bank=[];;;;;	    File.read(@bankdir+"/"+b.to_s+".dat").split("\n").each { |l| bank<<eval(l)};;;;;	    bank.each {|i| if i[0].to_s.downcase==name.to_s.downcase;found=[b,bank.index(i)];break;end};;;;;	  end;;;;;	  ;;;;;	  ##reload current bank;;;;;	  if unloaded;load_bank(@index);end;;;;;	  ;;;;;    end;;;;;	writelog("Search operation complete, result for '"+name.to_s+"' "+found.to_s+".");;;;;    return found;;;;;  end;;;;;  ;;;;;  ##add a new item to current bank;;;;;  def add(name);;;;;    writelog("Attempting to add the item '"+name.to_s+"' to bank "+@index.to_s+".");;;;;    ##check if word already exists in a bank so we dont add duplicates;;;;;    search=self.search(name);;;;;	if search==false;;;;;	  writelog("Item '"+name.to_s+"' was not found in any banks.");;;;;	  ##check if current bank has room to add the word, create a new bank if not;;;;;	  if @bank.length<@config[0].to_i;;;;;	    @bank<<[name.to_s];;;;;		writelog("Item '"+name.to_s+"' was added to bank "+@index.to_s+".");;;;;	  else;;;;;	    writelog("Current bank "+@index.to_s+" is full, a new bank must be created.");;;;;	    if @bank.length!=@bank_load_length;save_bank;end;;;;;	    load_open_bank;;;;;	    @bank<<[name.to_s];;;;;		@bank=@bank.sort;;;;;		writelog("Item '"+name.to_s+"' was added to newly created bank "+@index.to_s);;;;;	  end;;;;;	  return [@index,@bank.length-1];;;;;	else;;;;;	  writelog("Item was not added because it aleady exists at "+search.to_s);;;;;	  return false;;;;;    end;;;;;  end  ;;;;;  ;;;;;  ;;;;;  def writelog(str);;;;;    begin;;;;;	;;;;;	f=File.open(@logpath,"a");f.write(Time.now.to_s+" : "+str.to_s+"\n");f.close;;;;;	if defined?(@config);;;;;	  if @config[1].to_s=="1";puts str.to_s;end;;;;;	end;;;;;	;;;;;	rescue;;;;;	;;;;;	begin;;;;;	;;;;;	if File.file?(@logpath)==false;f=File.open(@logpath,"w");f.close;end;;;;;	f=File.open(@logpath,"a");f.write(Time.now.to_s+" : "+str.to_s+"\n");f.close;;;;;	;;;;;	rescue; SYSTEM.errorlog("Dictionry logwrite failed: "+str.to_s);;;;;	end;;;;;	;;;;;	end;;;;;  end  ;;;;;   ;;;;;  ;;;;;  def digest(string)  ;;;;;    words=[];;;;;	chars="\\\"'`!~@$#%^&*()-_=+[{]}|:;<>?,./\n\t";;;;;	string.to_s.downcase.tr(chars," ").split(" ").each { |s| if s.only_letters?;words<<s;end };;;;;	if words.length>0;;;;;	  ;;;;;	  words=words.to_s.downcase;  words=eval(words)  ## MAKE SURE YOU CAN DOWNCASE SUCH A MASSIVE STRING;;;;;	  ;;;;;      nwords=[]	;;;;;	  words.each { |w| unless nwords.include?(w);  nwords << w ; end };;;;;	  ;;;;;	  words=nwords;;;;;	  ;;;;;	  added=0;;;;;	  words.each { |w| if self.add(w) != false;added+=1;end };;;;;	  return added;;;;;	    ;;;;;	else;return 0;;;;;	end;;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  def clean_bank  ;;;;;    @bank.each do |b|;;;;;	  pass=true;;;;;	  i=@bank.index(b);;;;;	  deleted=0;;;;;	;;;;;	;;;;;	  ;;;;;	;;;;;	  if pass!=true;@bank.delete_at(i);deleted+=1;end;;;;;	end;;;;;  ;;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;end;;;;;;;;;;#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/host.rb#1#::#1#::#0#::#0#::#0#::#0#::#1#class Host_Manager;;;;;  def initialize;;;;;    @host="Windows_NT";;;;;    @auto_start_dir=ENV["HOMEDRIVE"]+"/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp";;;;;  end;;;;;  ;;;;;  def launch(path) ##launch a rb, cmd, lnk file in new window;;;;;    if File.file?(path);;;;;	  begin;;;;;	    cdir=Dir.getwd;;;;;	    Dir.chdir(path.to_s.split("/")[0..-2].join("/"));;;;;	    n=path.to_s.split("/")[-1];;;;;		system(n.to_s);;;;;		Dir.chdir(cdir);;;;;		return true;;;;;	  rescue; return false;;;;;	  end;;;;;	else;return false;;;;;	end;;;;;  end;;;;;  ;;;;;  def launch_new(path) ## launch in current consol host;;;;;    if File.file?(path);;;;;	  begin;;;;;	    cdir=Dir.getwd;;;;;	    Dir.chdir(path.to_s.split("/")[0..-2].join("/"));;;;;	    n=path.to_s.split("/")[-1];;;;;		system("start "+n.to_s);;;;;		Dir.chdir(cdir);;;;;		return true;;;;;	  rescue; return false;;;;;	  end;;;;;	else;return false;;;;;	end;;;;;  end;;;;;  ;;;;;  def get_host_identifier; return ENV["COMPUTERNAME"]+":"+ENV["OS"]+":"+ENV["platformcode"]+":"+ENV["PROCESSOR_ARCHITECTURE"]+":"+ENV["PROCESSOR_IDENTIFIER"]+":"+ENV["PROCESSOR_REVISION"]; end ;;;;;  ;;;;;  ## get a list of drives mounted;;;;;  def drives;;;;;    mounted=[];;;;;    ["C:/","D:/","E:/","F:/"].each { |d| if File.directory?(d);mounted<<d;end };;;;;	return mounted;;;;;  end;;;;;  ;;;;;  ## figure out which drive host is installed on;;;;;  def host_drive;;;;;    return ENV["HOMEDRIVE"];;;;;  end;;;;;  ;;;;;  ;;;;;  def procs;;;;;    str=`TASKLIST`;;;;;	procs=[];;;;;  ;;;;;    str.split("\n")[3..-1].each do |line|;;;;;	  name=line[0..24].split("  ").join("");;;;;      pid=line[26..33].split("  ").join("")	  ;;;;;	  session_name=line[35..50].split("  ").join("");;;;;	  session_n=line[52..62].split("  ").join("");;;;;	  mem_usag=line[64..75].split("  ").join("");;;;;	  ;;;;;	  procs << [name,pid,session_name,session_n,mem_usag];;;;;	end;;;;;    return procs;;;;;  end;;;;;  ;;;;;  def memory_used;;;;;    b=0;;;;;	;;;;;	self.procs.each do |p|;;;;;	  b += p[-1].delete(" ,K").to_i;;;;;	end;;;;;;;;;;    return b.commas+" K";;;;;  end;;;;;  ;;;;;  def memory_installed;;;;;  end;;;;;  ;;;;;  def cmd(str);;;;;	begin;;;;;	  res=self.instance_eval("`"+str.to_s+"`");;;;;	rescue => e;  res=e.to_s;;;;;	end;;;;;	return res;;;;;  end;;;;;  ;;;;;  def name;  return ENV["COMPUTERNAME"];  end;;;;;  ;;;;;end#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/install.rb#1#::#1#::#0#::#0#::#0#::#0#::#1#class Installation_Manager;;;;;  def initialize;;;;;       ;;;;;	   ;;;;;	   ;;;;;	   ;;;;;	@default_index_package=[["/rubin/system/daemond.rb",;;;;;	  "/rubin/system/controller.rb",;;;;;	  "/rubin/system/definitions.rb",;;;;;	  "/rubin/system/dictionary.rb",;;;;;	  "/rubin/system/host.rb",;;;;;	  "/rubin/system/install.rb",;;;;;	  "/rubin/system/instance.rb",;;;;;	  "/rubin/launch.rb",;;;;;	  "/rubin/launch irb.cmd",;;;;;	  "/rubin/system/network.rb",;;;;;	  "/rubin/system/rubin.rb",;;;;;	  "/rubin/system/ruby.rb"],;;;;;	["/rubin/system",;;;;;	 "/rubin/app",;;;;;     "/rubin/class",;;;;;     "/rubin/data",;;;;;     "/rubin/shortcuts",;;;;;     "/rubin/data/appdata",;;;;;     "/rubin/data/backups",;;;;;     "/rubin/data/config",;;;;;     "/rubin/data/definitions",;;;;;     "/rubin/data/fileio",;;;;;     "/rubin/data/logs",;;;;;     "/rubin/data/scripts",;;;;;     "/rubin/data/sys",;;;;;     "/rubin/data/sys/instance",;;;;;     "/rubin/data/temp",;;;;;     "/rubin/data/user"]];;;;;    	;;;;;  end;;;;;  ;;;;;  def default_index; return @default_index_package;  end;;;;;  ;;;;;  def id; return INSTALLATION_HEADER[5];;;;;  end;;;;;  def dir; return INSTALLATION_HEADER[1];;;;;  end;;;;;  def verify_dir;return INSTALLATION_HEADER[1].to_s.downcase==SYSTEM.homedir.to_s.downcase;;;;;  end;;;;;  def date; return INSTALLATION_HEADER[3];;;;;  end;;;;;  def version; return INSTALLATION_HEADER[2];;;;;  end;;;;;  def verify_installation_files(path);;;;;    if path.to_s.downcase.split("/")[-1]=="rubin";;;;;	  if File.file?(path+"/system/rubin.rb");return true;end;;;;;	end;;;;;	return false;;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  def default_build_package;;;;;    a=self.default_index[0];  b=self.default_index[1];;;;;    self.build_package(a,b);;;;;  end;;;;;  ;;;;;  ;;;;;  ## build a source package file from installed version;;;;;  def build_package *args #(included_files,included_dir_paths)     ;;;;;    included_files=args[0];;;;;	included_dir_paths=args[1];;;;;    files_data=[];;;;;	maindatasep="#1#::#1#::#0#::#0#::#0#"+"::#1#::#1#";;;;;	filenamesep="#1#::#1#::#0#::#0#::#0#"+"::#0#::#1#";;;;;	filesep="#1#::#1#::#0#::#0#::#0#"+"::#0#::#0#";;;;;    index_sep="#1#::#0#::#0#::#0#::#0#"+"::#"+"0#::#1#";;;;;    ;;;;;	##get index file paths;;;;;    index_files=[];;;;;	included_files.each do |f|;;;;;	  p=f.to_s.downcase.split("/rubin/")[-1];;;;;	  index_files << "/rubin/"+p;;;;;	end;;;;;	;;;;;	## locations of actual resources;;;;;	nincluded_files=[];;;;;	included_files.each do |f|;;;;;	  p = f.to_s.downcase.split("/rubin/")[-1];;;;;	  nincluded_files << INSTALLATION_HEADER[1].to_s+"/"+p;;;;;	end;;;;;	;;;;;	included_files=nincluded_files;;;;;    ;;;;;	##get index dir paths ;;;;;	index_dirs=[];;;;;	included_dir_paths.each do |d|;;;;;	  p=d.to_s.downcase.split("/rubin/")[-1];;;;;	  index_dirs << "/rubin/"+p;;;;;	end;;;;;;;;;;    ##make index string;;;;;    index1=index_files.join("?");;;;;    index2=index_dirs.join("?");;;;;    index=index1+"??"+index2;;;;;    ;;;;;	## get data of all the files;;;;;    files_data=[];;;;;	included_files.each do |f|;;;;;	  f=File.open(f,"r");files_data << f.read ;  f.close;;;;;	end;;;;;	;;;;;	##combine files data with their index paths;;;;;	nfiles_data=[];;;;;	files_data.each do |fd|;;;;;	  i=files_data.index(fd);;;;;	  p=index_files[i.to_i];;;;;	  da=""+p.to_s+filenamesep+fd.to_s;;;;;	  nfiles_data << da;;;;;	end;;;;;	;;;;;	filespkg = nfiles_data.join(filesep);;;;;	;;;;;    final_data = maindatasep.to_s + index.to_s + index_sep.to_s + filespkg.to_s;;;;;	;;;;;	final_data=final_data.split("\n").join(";;"+";;;");;;;;	;;;;;	d=SYSTEM.datadir+"/backups/installpackage.txt";;;;;	;;;;;	f = File.open(d,"w");f.write(final_data);  f.close;;;;;	;;;;;	return "Your file was built: "+d.to_s;;;;;;;;;;  end;;;;;;;;;;  #install.install_package("E:/Rubin/data/backups/installpackage.txt","C:/Users/14809/Desktop");;;;;;;;;;  def install_package(package,dir);;;;;    if self.verify_installation_files(dir) == true ;  raise "Rubin is already installed there.";   end;;;;;    if File.file?(package) == false;  raise "Input file path is incorrect.";  end;;;;;	;;;;;	##load data;;;;;	f=File.open(package,"r"); data = f.read ; f.close;;;;;	;;;;;	##decode data;;;;;	data=data.split(";;;"+";;").join("\n");;;;;	;;;;;	maindatasep="#1#::#1#::#0#::#0#::#0#"+"::#1#::#1#";;;;;	filenamesep="#1#::#1#::#0#::#0#::#0#"+"::#0#::#1#";;;;;	filesep="#1#::#1#::#0#::#0#::#0#"+"::#0#::#0#";;;;;    index_sep="#1#::#0#::#0#::#0#::#0#"+"::#0#::#1#";;;;;	;;;;;	data=data.split(maindatasep)[-1];;;;;;;;;;	index_string=data.to_s.split(index_sep)[0].to_s;;;;;	;;;;;	file_data=data.split(index_sep)[-1];;;;;		##process files;;;;;	;;;;;	;;;;;	file_data=file_data.split(filesep);;;;;	;;;;;	nfile_data=[];;;;;	;;;;;	file_data.each do |d|;;;;;	  p=d.split(filenamesep)[0];;;;;	  di=d.split(filenamesep)[1];;;;;	  nfile_data<<[p,di];;;;;	end;;;;;	;;;;;	file_data=nfile_data;;;;;	;;;;;	#proces index;;;;;	load "";;;;;	f = index_string.split("??")[0].split("?");;;;;	di = index_string.split("??")[1].split("?");;;;;;;;;;;;;;;    Dir.mkdir(dir.to_s+"/rubin");;;;;;;;;;	di.each do |p|;;;;;	  np=dir+"/"+p;;;;;	  Dir.mkdir(np);;;;;	end;;;;;;;;;;    # create files;;;;;   ;;;;;    file_data.each do |fd|;;;;;	  p=dir.to_s+"/"+fd[0].to_s;;;;;	  f=File.open(p,"w");  f.write(fd[1].to_s);  f.close;;;;;	end;;;;;;;;;;    p=dir.to_s+"/rubin/system/rubin.rb";;;;;	f=File.open(p,"r");  dat=f.read;  f.close;;;;;    ;;;;;    old_header=dat.split("\n")[0].split("INSTALLATION_HEADER=")[-1];;;;;    old_header=eval(old_header.to_s);;;;;;;;;;    dat=dat.split("\n")[1..-1].join("\n");;;;;;;;;;    version=old_header[2].to_s ### for now itll be bugged and write the version as the one of the installing party not the packaged, fix later;;;;;    head=["installed",dir+"/rubin",version,Time.now.to_s,ENV["USER"].to_s,rand(99999999999999).to_s(36)];;;;;    str="INSTALLATION_HEADER="+head.to_s;;;;;;;;;;	;;;;;	ndat=str+"\n"+dat;;;;;	f=File.open(p,"w");  f.write(ndat);  f.close;;;;;;;;;;    return true;;;;;  ;;;;;  end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;  ;;;;;;;;;;end#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/instance.rb#1#::#1#::#0#::#0#::#0#::#0#::#1#class Instance;;;;;  def initialize;;;;;    ;;;;;	;;;;;	;;;;;	;;;;;	##check fileio binding for ones marked public;;;;;    ;;;;;  end;;;;;  ;;;;;  def get_local_ids;;;;;    i=Dir.entries(SYSTEM.datadir+"/sys/instance");;;;;	if i.length>0;;;;;	  l=[];fl=[];;;;;      i.each do |f|;;;;;	    if f.to_s.downcase[-4..-1]==".dat" and f.to_s[0..-5].delete("0123456789").length==0;;;;;	      l<<f[0..-5];;;;;	    end;;;;;	  end;;;;;	  if l.length>0;;;;;	    l.each do |ll|;;;;;	      f=File.read(SYSTEM.datadir+"/sys/instance/"+ll.to_s+".dat");;;;;		  str=Time.stamp(f);;;;;		  sec=Time.now-str;;;;;		  if sec.to_i<30;;;;;		    fl<<ll;;;;;		  end;;;;;	    end;;;;;		return fl;;;;;	  else; return [];;;;;	  end;;;;;	else; return [];;;;;	end;;;;;  end;;;;;  ;;;;;  ;;;;;  def id ; return INSTANCE ; end;;;;;  ;;;;;  ;;;;;  def pop;;;;;    SYSTEM.host.launch_new(SYSTEM.homedir+"/launch.rb");;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;;;;;;  ;;;;;  ;;;;;  ;;;;;  class Group_Member_Host;;;;;    ;;;;;  end;;;;;;;;;;  class Group_Member;;;;;    ;;;;;  end  ;;;;;  ;;;;;  ;;;;;end#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/launch.rb#1#::#1#::#0#::#0#::#0#::#0#::#1###this file should never be anything more than a shortcut;;;;;## shortcuts to this file can have their own window config;;;;;;;;;;load Dir.getwd.to_s+'/system/rubin.rb'#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/launch irb.cmd#1#::#1#::#0#::#0#::#0#::#0#::#1#start irb#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/network.rb#1#::#1#::#0#::#0#::#0#::#0#::#1#class Network_Manager;;;;;  def initialize;;;;;  ;;;;;  end;;;;;  ;;;;;  ;;;;;  def internet?;;;;;  ;;;;;  end;;;;;  ;;;;;  def get_html(url);;;;;  ;;;;;  end;;;;;  ;;;;;  def download_page(url,path);;;;;  ;;;;;  end;;;;;  ;;;;;  ;;;;;end#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/rubin.rb#1#::#1#::#0#::#0#::#0#::#0#::#1#INSTALLATION_HEADER=["installed","E:/Rubin","1.0.0","2023.2.1","thoma","D94JG8EH4"]#INSTALLATION_HEADER_END;;;;;##First line will always be the install headder;;;;;require 'bundler/inline';;;;;require 'open-uri';;;;;;;;;;###############################################################################;;;;;### BOOT;;;;;;;;;;puts "Checking system...";BOOT_INIT_TIME=Time.now;;;;;boog_log=[];;;;;##check workdir;;;;;if Dir.getwd.to_s.downcase!=INSTALLATION_HEADER[1].to_s.downcase;;;;;  if File.exist?(INSTALLATION_HEADER[1]);;;;;    msg=Time.now.to_s+" : ERROR : Work directory is not installation directory. It had to be changed."  ;;;;;    boog_log << msg;;;;;    $homedir=INSTALLATION_HEADER[1];;;;;	Dir.chdir($homedir)	## this is mostly optional;;;;;	puts msg.to_s;;;;;  else ;;;;;	msg=Time.now.to_s+" : ERROR : CRITICAL : Installation not found!";;;;;    boog_log << msg;;;;;	puts boog_log.join("\n");;;;;	exit  ## ABORT BOOT installation not found;;;;;  end  ;;;;;else;$homedir=Dir.getwd;;;;;end;;;;;;;;;;if File.writable?($homedir)!= true;;;;;  msg=Time.now.to_s+" : ERROR : CRITICAL : Installation directory is not writable per host!";;;;;  boog_log << msg;;;;;  puts boog_log.join("\n");;;;;  ##try to run anyways;;;;;end;;;;;;;;;;## make a temporary log to help if this boot gets rockey.;;;;;f=File.open($homedir+"/bootlog.log","w");f.write("\n"+Time.now.to_s+" : Boot initiated.\n"+boog_log.join("\n"));f.close;;;;;  ;;;;;## Ensure system file exists.;;;;;if File.exist?(INSTALLATION_HEADER[1]+"/system/rubin.rb")==false;;;;;  msg=Time.now.to_s+" : ERROR : CRITICAL : system file can not be located!";;;;;  f=File.open($homedir+"/bootlog.log","a");f.write(msg);f.close;;;;;  exit  ## ABORT BOOT installation not found;;;;;end;;;;;;;;;;## Boot criteria met, proceed;;;;;msg=Time.now.to_s+" : BOOT SUCCESS.";;;;;f=File.open($homedir+"/bootlog.log","a");f.write(msg+"\n");f.close;;;;;;;;;;puts "Initializing...";;;;;;;;;;######################################################################;;;;;## Startup;;;;;;;;;;;;;;;;;;;;BOOTTIME=Time.now                     ##;;;;;MAIN=self                             ##Somewhat global reference to this context.;;;;;INSTANCE=rand(100000);;;;;;;;;;$sysdir=$homedir+"/system"              ##Rubin system code and system files like cfg and cache.;;;;;$appdir = $homedir+"/app"               ##Location of installed ruby applications.;;;;;$classdir=$homedir+"/class"             ##Classes loaded with ruby, for redefinitions and adding features.;;;;;$datadir=$homedir+"/data"               ##General purpose data directory.;;;;;$appdatadir = $homedir+"/data/appdata"    ##For apps to store files and folders in.;;;;;$cfgdir= $homedir+"/data/config"            ##For apps and user config data.;;;;;$logdir = $homedir+"/data/logs"         ##General log directory. System and boot logs are here too.;;;;;$userdir = $homedir+"/data/user"          ##General directory for apps to keep user data in.;;;;;$bindir=$homedir+"/bin"                 ##For host executable files like interpreters and random exes.;;;;;;;;;;;;;;;class RubinSystem;;;;;  ;;;;;  VERSION=INSTALLATION_HEADER[2].to_s   ## LAST VERSION UPGRADE 8-12-2022;;;;;    ;;;;;  def initialize;;;;;;;;;;  end;;;;;  def startup;;;;;	if defined?(POST_INITIALIZATION);  return "false";  end;;;;;	;;;;;    @homedir=$homedir;;;;;    @sysdir=@homedir+"/system" ;;;;;    @appdir = @homedir+"/app"   ;;;;;    @classdir=@homedir+"/class"   ;;;;;    @datadir=@homedir+"/data"   ;;;;;    @appdatadir = @homedir+"/data/appdata";;;;;    @cfgdir= @homedir+"/data/config"            ;;;;;    @logdir = @homedir+"/data/logs"         ;;;;;    @userdir = @homedir+"/data/user"       ;;;;;    @bindir=@homedir+"/bin"             ;;;;;;;;;;	@daemond=nil              ## reserved for main system threadpool;;;;;    @definitions=[];;;;;	@apps=[]                  ## list of app objs and threads loaded   ;;;;;    @components=[]		;;;;;	@loaded_apps=[]           ## list of app loads on system;;;;;    @classes=[];;;;;	@app=nil;@threads=[];     ## reserved for system ;;;;;	;;;;;    @shell=nil;;;;;	;;;;;	## enforce file system;;;;;	["/app","/class","/data","/shortcuts","/data/appdata","/data/config","/data/logs","/data/user","/data/definitions","/data/fileio","/data/backups"].each do |f|;;;;;	  unless File.exist?(@homedir+f);;;;;	    Dir.mkdir(@homedir+f);;;;;	    begin self.errorlog("SYSTEM ERROR: Missing directory repaired: "+@homedir+"/"+f.to_s);;;;;		rescue;;;;;		end;;;;;	  end;;;;;    end;;;;;	;;;;;    ##Move boot log into major boot log;;;;;    if File.exist?(@homedir+"/bootlog.log");;;;;	  f=File.open(@homedir+"/bootlog.log","r");log=f.read;f.close;;;;;	  f=File.open(@logdir+"/bootlog.log","a");f.write(log);f.close;;;;;	  File.delete(@homedir+"/bootlog.log");;;;;	else;self.errorlog("Boot log was missing for this boot.");;;;;	end;;;;;;;;;;    ## setup config data;;;;;	@config_names=["LoadClasses","AutoStartApps","RubinStartOnBoot",;;;;;    "SystemShellAutoStart","DebugMode","DaemondDelay","ShowLogWrites",;;;;;    "CtrlNetdir","LoadDefinition","EvaluateFileIO","EvaluateFileIOPrint","RubyGems","AutoScripts"];;;;;	@default_config=[true,[],false,true,true,10,false,"",true,false,false,[],[]];;;;;    @config=@default_config;;;;;	;;;;;	puts "Loading config data...";;;;;    ##check for preconfig or load default config	;;;;;    preconfig=false;;;;;	f=Dir.entries(@cfgdir)[2..-1];;;;;    if f.length>0;;;;;	  pf=[];;;;;	  f.each do |ff|;;;;;	    if ff.to_s.downcase[0..8]=="preconfig" and ff.to_s.downcase[-4..-1]==".cfg";;;;;          pf<<ff;;;;;	    end;;;;;	  end  ;;;;;	  if pf.length>0;;;;;	    pf=pf.sort;;;;;		preconfig=@cfgdir+"/"+pf[0].to_s;;;;;	  end;;;;;	end;;;;;	v=false;;;;;	if preconfig!=false and File.file?(preconfig);;;;;      v=self.load_config(preconfig);;;;;	  if v !="error" and v != false;;;;;        File.delete(preconfig);;;;;      end	  ;;;;;	  puts "Loaded preconfig: "+preconfig.split("/")[-1].to_s;;;;;    else ## no preconfig;;;;;	  v=self.load_config;;;;;	  puts "Default config was loaded.";;;;;	end;;;;;	;;;;;	if v=="error";;;;;	  self.errorlog("Config file was corrupted. Restoring to default.");;;;;	  self.save_config;;;;;	elsif v==false;;;;;	  self.errorlog("Restoring config to default");;;;;	  self.save_config;;;;;	end;;;;;;;;;;;;;;;	##load/install rubygems;;;;;	if @config[11].length>0;;;;;	  puts "Loading Ruby Gems...";;;;;	  required=@config[11];;;;;	  gems=`gem list`;gems=gems.split("\n");;;;;	  gemfiles=[];gems.each {|g| gemfiles<<g.split(" (")[0]};;;;;      required.each do |r|;;;;;	    if gemfiles.include?(r)==false;;;;;          self.writelog("Attempting to install rubygem: "+r)		;;;;;		  puts "Ruby gem is being installed: "+r+" ...";;;;;		  begin;;;;;		    gemfile do;;;;;              source 'https://rubygems.org';;;;;              gem r.to_s;;;;;            end;;;;;		    require r.to_s;;;;;		  rescue;msg="Ruby gem could not be installed: "+r.to_s;;;;;		    self.errorlog(msg);;;;;;		    puts msg;;;;;          end;;;;;		else;require r.to_s;;;;;		end;;;;;	  end;;;;;	end  ;;;;;	 ;;;;;	##load definition if configured;;;;;;;;;;    if @config[8].to_s=="true" and File.file?(@homedir+"/system/definitions.rb") == true;;;;;	  ;;;;;	  begin;;;;;		SYSTEM.instance_eval(File.read(@homedir+"/system/definitions.rb"));;;;;		@definitions<<"definitions.rb";;;;;		puts "Applied definition: definitions.rb";;;;;	  rescue => e;;;;;	    msg="Definitions.rb produced an excption.\n"+e.to_s+"\n"+e.backtrace[0..5].join("\n");;;;;		self.errorlog(msg);;;;;		puts msg.to_s;;;;;	  end ;;;;;	  ;;;;;	elsif @config[8].length>0;;;;;	  puts "Loading "+@config[8].length.to_s+" definitions...";;;;;	  @config[8].each do |file|;;;;;	    begin;;;;;	      SYSTEM.instance_eval(File.read(@datadir+"/definitions/"+file.to_s));;;;;		  @definitions<<file.to_s;;;;;		  puts "Applied definition: "+file.to_s;;;;;	    rescue => e;;;;;	      msg="Definitions.rb produced an excption.\n"+e.to_s+"\n"+e.backtrace[0..5].join("\n");;;;;          self.errorlog(msg);;;;;		  puts msg.to_s;;;;;	    end;;;;;	  end;;;;;	end;;;;;;;;;;;;;;;	##Load class files if configured to.;;;;;    if @config[0]==true;;;;;	  v=self.load_classes;;;;;	  if v!=0;puts "Loaded "+v.to_s+" classes.";;;;;	  else;puts "No classes were found.";;;;;	  end;;;;;	end;;;;;	;;;;;	;;;;;	## execute system startup procedures(auto start apps and config changes/settings)	;;;;;	@shell=SystemShell.new;;;;;	;;;;;	##load components;;;;;	;;;;;	preconstants=self.constants;;;;;	;;;;;	@real_components=[];;;;;	@components=[];;;;;	c=Dir.entries(@sysdir)[2..-1];;;;;	if c.length>3;;;;;	  puts "Loading components: " + (c.length-3).to_s;;;;;	  self.writelog("Loading system components: "+c.to_s);;;;;	  c.each {|c| unless c.to_s.downcase=="rubin.rb" or c.to_s.downcase=="daemond.rb" or c.to_s.downcase=="definitions.rb";@components<<c;end};;;;;	  if @components.length>0;;;;;	    @components.each do |c|;;;;;	      begin;load @sysdir+"/"+c;;;;;		  rescue => e ; puts e.to_s;;;;;		    self.writelog("Exception loading system component: "+c.to_s);;;;;	      end;;;;;	    end;;;;;	  end;;;;;	end;;;;;	;;;;;	postconstants=self.constants;;;;;    preconstants.each { |c| postconstants.delete(c) };;;;;    preivs=self.instance_variables;;;;;	postconstants.each { |c|;;;;;	  ivn="@"+c.downcase.to_s;;;;;	  begin;;;;;        self.writelog("Initializing component: "+c.to_s);;;;;	    self.instance_eval(ivn.to_s+"="+c.to_s+".new()");;;;;	  rescue => e;;;;;	    self.errorlog("Component initialization failed: "+c.to_s+e.to_s+"\n"+e.backtrace.join("\n"));;;;;	  end;;;;;	};;;;;	postivs=self.instance_variables;;;;;	preivs.each { |iv| postivs.delete(iv) };;;;;    @components=postivs;;;;;	;;;;;	@components.each do |c|;;;;;	  self.instance_eval("@real_components << "+c.to_s);;;;;	end;;;;;;;;;;	@real_components.each do |c|;;;;;	  if c.methods.include?(:post_initialization);;;;;	    c.post_initialization;;;;;	  end;;;;;	end;;;;;	;;;;;	;;;;;;;;;;	self.writelog("Initialization finished.");;;;;;;;;;	puts "Rubin is starting up.";;;;;  end;;;;;;;;;;  def components;return @components;  end;;;;;  def dirs *args;;;;;    if args.length==1 and args[0].is_a?(String);;;;;	  dirname=args[0];;;;;      if dirname.to_s.downcase=="homedir";return @homedir;;;;;      elsif dirname.to_s.downcase=="sysdir";return @sysdir;;;;;      elsif dirname.to_s.downcase=="appdir";return @appdir;;;;;      elsif dirname.to_s.downcase=="classdir";return @classdir;;;;;      elsif dirname.to_s.downcase=="datadir";return @datadir;;;;;      elsif dirname.to_s.downcase=="logdir";return @logdir;;;;;      elsif dirname.to_s.downcase=="cfgdir";return @cfgdir;;;;;      elsif dirname.to_s.downcase=="appdatadir";return @appdatadir;;;;;      else;return false;;;;;	  end;;;;;	else;return ["homedir","sysdir","appdir","classdir","datadir","logdir","cfgdir","appdatadir"];;;;;	end;;;;;  end  ;;;;;  def homedir;return @homedir;  end;;;;;  def sysdir;return @sysdir;  end;;;;;  def datadir;return @datadir;  end;;;;;  def appdir;return @appdir;  end;;;;;  def classdir; return @classdir;  end;;;;;  def appdatadir;return @appdatadir;  end;;;;;  def logdir;return @logdir;  end;;;;;  def cfgdir;return @cfgdir;  end  ;;;;;  ##for some weird reason you cant call this method normally in rubin class scope unless it is defined here;;;;;;;;;; ;;;;; ;;;;; def install;return @installation_manager;  end;;;;;  def ruby; return @ruby_manager;  end;;;;;  def network;return @network_manager;  end;;;;;  def host;return @host_manager;  end;;;;;  def dic;return @dictionary;  end;;;;;  def fileio ; return @fileio ; end;;;;;  def instance;return @instance;end;;;;;  def instance_id; return INSTANCE ; end;;;;;;;;;; ;;;;;;;;;;  def start_daemond   ;;;;;    puts "Starting daemond...";;;;;    if defined?(POST_INITIALIZATION);return false;end;;;;;    begin;@daemond=SystemDaemond.new;;;;;	  self.writelog("System daemond has started.");return true;;;;;	rescue => e ; msg="System Daemond produced exception: "+e.to_s+"\n"+e.backtrace.join("\n");;;;;	  self.writelog(msg);;;;;	  raise msg;;;;;	end;;;;;  end;;;;;;;;;;  def post_initialization;;;;;    unless defined?(POST_INITIALIZATION); ;;;;;	  if @config[1].length>0 ##we have startup apps to run;;;;;	    msg = "Loading "+@config[1].length.to_s+" startup apps.";;;;;		self.writelog(msg);;;;;		@config[1].each do |app|;;;;;		  puts "Running autostart app: "+app.to_s;;;;;		  self.run(app);;;;;		end;;;;;	  end;;;;;	  self.writelog("System startup successfull.");;;;; 	  puts "Startup complete Rubin is now running!, Started up in "+(Time.now-BOOT_INIT_TIME).to_s[0..3]+" seconds.\nThe time is: "+Time.now.to_s;;;;;	  ;;;;;	  if @config[12].length>0;;;;;	    @config[12].each do |f|;;;;;		  if File.file?(@datadir+"/scripts/"+f.to_s);;;;;		    begin ;;;;;			  str=File.read(@datadir+"/scripts/"+f.to_s);;;;;			  begin;;;;;			    self.instance_eval(str);;;;;  			    self.writelog("Autoscript loaded: "+f.to_s);;;;;			    puts "Autoscript loaded: "+f.to_s;;;;;			  rescue => e ; self.errorlog("Autoscript produced an exception: "+ e.to_s);;;;;			  end;;;;;			rescue ##unable to read autoscript;;;;;			end;;;;;		  end;;;;;		end;;;;;	  ;;;;;	  end;;;;;	  ;;;;;	  ############################	  ;;;;;	  if @config[3].to_s.downcase=="true";;;;;	    self.writelog("Starting system shell.");;;;;	    if defined?(NOSHELL)==nil;;;;;		  puts "Starting system shell.";;;;;		  self.shell.start(self);;;;;		end;;;;;	  end	  ;;;;;    end;;;;;  end;;;;;;;;;;  def shutdown *args;;;;;    proceed=false;;;;;	if args[0].to_s[0]=="F";;;;;      proceed=true;;;;;    else;;;;;	  puts "\nAre you sure you want to shutdown Rubin? Y/N";;;;;	  inp=gets.chomp[0].downcase;;;;;	  if inp=="y";proceed=true;end;;;;;	end;;;;;	if proceed;;;;;	  self.writelog("System Shutting down.");;;;;	  ;;;;;	  self.save_config;;;;;	  self.save_cache;;;;;	  ;;;;;	  #maybe attempt to call the method shutdown for each class if it exists;;;;;	  #@apps.each {|a| a[0].defined?(shutdown) }  ## do apps only have one thread? thius might be an array of threads;;;;;	  ;;;;;	  @apps.each {|a| v = a[-2];  if v.is_a?(Thread);  v.kill ;  end}  ## do apps only have one thread? thius might be an array of threads;;;;;	  ;;;;;	  self.writelog("Stopped apps.");;;;;	  @daemond.kill;;;;;	  self.writelog("Stopped system daemond.");;;;;	  begin;;;;;	  File.delete(@datadir+"/sys/instance/"+INSTANCE.to_s+".dat");;;;;	  rescue;;;;;	  end;;;;;	  self.writelog("System is down.");;;;;	  puts "System is ready to shutdown";;;;;	  sleep 5.0;;;;;	  exit;;;;;	end;;;;;  end;;;;;  ;;;;;  def restart *args;;;;;    proceed=false;;;;;	if args[0].to_s[0]=="F";;;;;      proceed=true;;;;;    else;;;;;	  puts "\nAre you sure you want to restart Rubin? Y/N";;;;;	  inp=gets.chomp[0].downcase;;;;;	  if inp=="y";proceed=true;end;;;;;	end;;;;;	if proceed==false;  return false;  end;;;;;	;;;;;	self.save_config;;;;;	self.save_cache;;;;;	@apps.each {|a| v = a[-2];  if v.is_a?(Thread);  v.kill ;  end}  ## do apps only have one thread? thius might be an array of threads;;;;;	self.writelog("Stopped apps.");;;;;	@daemond.kill;;;;;	begin;File.delete(@datadir+"/sys/instance/"+INSTANCE.to_s+".dat");  rescue;;  end;;;;;	self.writelog("System is down. Prepairing to restart...");;;;;	sleep 1.0;;;;;	self.host.launch_new(@homedir+"/launch.rb");;;;;	sleep 0.1;;;;;	exit;;;;;  end;;;;;  ;;;;;  ;;;;;;;;;;  def writelog *args# ad option to print;;;;;	if File.file?(@logdir+"/systemlog.log")==false;f=File.open(@logdir+"/systemlog.log");f.close;end;;;;;	ts=Time.now.to_s.split(" ")[0..1].join(".").split(":").join(".").split("-").join(".");;;;;	str="\n"+ts+": "+INSTANCE.to_s+": "+args[0].to_s;;;;;	f=File.open(@logdir+"/systemlog.log","a");f.write(str);f.close;;;;;	if args[1].to_s.downcase=="true";puts "\n"+args[0].to_;end;;;;;  end;;;;;;;;;;  def errorlog(msg)  ;;;;;	ts=Time.now.to_s.split(" ")[0..1].join(".").split(":").join(".").split("-").join(".");;;;;	str="\n"+ts+": "+INSTANCE.to_s+": "+msg.to_s;;;;;	str2="\n"+ts+": "+INSTANCE.to_s+": An error occured: "+msg.to_s;;;;;	f=File.open(@logdir+"/errorlog.log","a");f.write(str.to_s);f.close	;;;;;	f=File.open(@logdir+"/systemlog.log","a");f.write(str2.to_s);f.close	;;;;;	begin;if @config[4].to_s.downcase=="true";puts "ERROR: "+msg.to_s;end;;;;;	rescue;puts "ERROR: "+str.to_s;;;;;	end;;;;;  end  ;;;;; ;;;;;  def config *args;;;;;    if args.length==0;;;;;	 cfg=[];@config_names.each {|c| cfg << [c,@config[@config_names.index(c)]]};;;;;	  return cfg;;;;;	elsif args[0].is_a?(Integer) and args.length==1;;;;;	  return @config[args[0].to_i];;;;;	elsif args[0].is_a?(Integer) and args.length==2;;;;;	  @config[args[0]]=args[1];;;;;	  return true;;;;;	elsif args[0].is_a?(String) and @config_names.include?(args[0]) and args.length==1;;;;;	  return @config[@config_names.index(args[0])];;;;;	elsif args[0].is_a?(String) and @config_names.include?(args[0]) and args.length==2;;;;;	  @config[@config_names.index(args[0])]=args[1];;;;;	  return true;;;;;	else;return false;;;;;	end;;;;;  end;;;;;  ;;;;;;;;;;  def get_config;return @config;end;;;;;  ;;;;;  def shell;return @shell;end;;;;;  ;;;;;  def cache *args;;;;;    if args.length==0;return @cache                                      ##get cache    - no args;;;;;    elsif args.length==1&&args[0].is_a?(Array);@cache=args[0]            ##set cache    - Array;;;;;	elsif args.length==1&&args[0].is_a?(Integer);return @cache[args[0]]   ##get index   - Integer;;;;;	elsif args.length==2&&args[0].is_a?(Integer);@cache[args[0]]=args[1] ##set index    - Integer, Object;;;;;	end;;;;;  end;;;;;  ;;;;;  def def_objectify_cache ## we may choose to store temp objects in the cache and need to turn them into strings, the name of the objext and reconstruction tag;;;;;  end;;;;;  ;;;;;  def save_cache;;;;;	begin;f=File.write(@datadir+"/cache.dat","w");f.write(@cache.to_s);f.close;;;;;	  self.writelog("Saved cache.");;;;;	  return @cache.to_s.length;;;;;	rescue;return false;;;;;	end;;;;;  end;;;;;  ;;;;;  def clear_cache;@cache=[];return nil;end;;;;;	;;;;;  def restore_cache;;;;;	if File.exist?(@datadir+"/cache.dat");;;;;	  f=File.open(@datadir+"/cache.dat","r");c=f.read;f.close;;;;;	  begin;@cache=eval(c);;;;;	    self.writelog("Loaded cache.");;;;;		return true;;;;;	  rescue;;;;;	    f=File.open(@datadir+"/corrupted_cache.dat","w");f.write(c);f.close;;;;;	    f=File.open(@datadir+"/cache.dat");f.write("");f.close;;;;;		self.errorlog("Error: Load cache failed. Back up was made and cache file was wiped.");;;;;		return false;;;;;	  end;;;;;	else;;;;;	  self.errorlog("Error: Load cache failed, cache file is missing.");;;;;	  return false;;;;;	end;;;;;  end;;;;;	;;;;;  def load_config *args ## you can pass a filepath to load config from or leave blank to load default;;;;;    file=false;;;;;    if args.length==0 and File.file?(@cfgdir+"/config.cfg");;;;;	  file=@cfgdir+"/config.cfg";;;;;    elsif File.file?(args[0].to_s) and args[0].to_s[-4..-1].to_s.downcase==".cfg";;;;;      file=args[0].to_s;;;;;    else;;;;;      return false;;;;;    end;;;;;	f=File.open(file.to_s,"r");cfg=f.read;f.close;;;;;	begin;cfg=eval(cfg);@config=cfg;@loaded_cfg_file=file.to_s;;;;;	  self.writelog("System config was loaded.");;;;;	  return true;;;;;	rescue ## CONFIG DATA CORRUPTED	   ;;;;;	  self.errorlog("System config load failed due to corruption.");;;;;	  return "error" ;;;;;    end	;;;;;  end;;;;;  ;;;;;  def save_config *args   ## you can pass a name to save config as or blank for default;;;;;    if args.length==0;;;;;	  f=File.open(@cfgdir+"/config.cfg","w");f.write(@config.to_s);f.close;;;;;	  self.writelog("System config saved.");;;;;	  return true;;;;;	elsif args[0].to_s.length>0;;;;;	  begin;;;;;	    f=File.open(@cfgdir+"/"+args[0].to_s+".cfg","w");f.write(@config.to_s);f.close;;;;;	    self.writelog("System config saved as '"+args[0].to_s+"'.cfg.");;;;;	    return true;;;;;	  rescue;;;;;	    return false;;;;;	  end;;;;;	else;;;;;	  return false;;;;;	end;;;;;  end;;;;;  ;;;;;  def repair_config;;;;;    self.writelog("System Config data is being repaired.");;;;;    @config=@default_config ;;;;;    self.save_config	 ;;;;;  end;;;;;  ;;;;;  def repair_cache  ## right now it just resets, later maybe corrupt data extractor;;;;;    self.writelog("System Cache data is being repaired.");;;;;	@cache=[];;;;;	self.save_cache;;;;;  end;;;;;  ;;;;;  def load_classes  ## load the contents of the class dir;;;;;    self.writelog("Searching for classes to load.");;;;;    n=Dir.entries(@classdir)[2..-1];;;;;	if n.length>0;;;;;	  self.writelog("Classes found: "+(n.length-2).to_s);;;;; 	  @classes=[];;;;;	  Dir.entries(@classdir)[2..-1].each do |i|;;;;;        begin;load @classdir+"/"+i; @classes<<i.to_s;;;;;		  self.writelog("Loaded class: "+i);;;;;	    rescue => e;;;;;		  self.errorlog("Loading class file failed: "+i+"\n"+e.to_s+"\n"+e.backtrace.join("\n").to_s);;;;;	    end;;;;;      end;;;;;	  return (n.length-2);;;;;	else;;;;;	  self.writelog("Attempted to load system classes but there were none.");;;;;	  return 0;;;;;	end;;;;;  end;;;;; ;;;;;  def apps?  ##returns an array of apps that are runnable;;;;;    apps=[];;;;;    i=Dir.entries(@appdir)[2..-1];;;;;    i.each do |p|;;;;;      if File.file?(@appdir+"/"+p)and p.split(".")[-1].downcase=="rb";;;;;	    apps << p[0..-4];;;;;	  end;;;;;	  if File.exist?(@appdir+"/"+p) and File.exist?(@appdir+"/"+p+"/"+p+".rb");;;;;	   apps << p;;;;;	  end;;;;;    end;;;;;    return apps  ;;;;;  end;;;;;;;;;;  def runs(scriptname)  ## a way to control loading scripts from with in the system, not much else use since .load already does this;;;;;    s=@datadir+"/scripts/"+scriptname.to_s; if s.to_s.downcase[-3..-1]!=".rb"; s=s+".rb";end;;;;;    begin;str=File.read(s);;;;;	  begin; self.instance_eval(str);;;;;	  rescue => e; return e;;;;;	  end;;;;;    rescue; return false;;;;;	end;;;;;  end;;;;;;;;;;  def run(appname) ## Appname;;;;;	#strip file extension if included;;;;;	if appname.to_s[-3..-1].to_s.downcase==".rb";appname=appname.to_s[0..-4];;;;;	else;appname=appname.to_s;;;;;	end;;;;;	##verify app installed;;;;;	if apps?.include?(appname)==false;self.errorlog("Attempted to load an invalid app name: "+appname); return "Invalid app name.";end;;;;;	##verify app path;;;;;    if File.exist?(@appdir+"/"+appname+".rb");;;;;	  path=@appdir+"/"+appname+".rb";;;;;	elsif File.exist?(@appdir+"/"+appname+"/"+appname+".rb");;;;;	  path=@appdir+"/"+appname+"/"+appname+".rb";;;;;    else;;;;;	   ;;;;;	end;;;;;	;;;;;	##load and evaluate app script;;;;;	begin;;;;;	;;;;;	  self.writelog("Loading app file: "+appname.to_s+".rb");;;;;      f=File.open(path,"r");source=f.read;f.close;;;;;	  @threads=[];threads=[];@app=nil;@appshell=false;;;;;	  self.eval(source);;;;;;;;;;	  if @threads.length>0;;;;;	    @threads.each {|t| threads << t };;;;;		self.writelog("App: "+appname.to_s+" : has loaded threads: "+threads.length.to_s);;;;;	  end;;;;;	  ;;;;;	  if @app!=nil;appobj=@app#self.writelog("App object loaded: "+appname.to_s);;;;;	  else;appobj=nil ;;;;;	  end;;;;;	  	  ;;;;;	  @apps<<[appname,Time.now.to_s,threads,appobj];;;;;	  @loaded_apps<<[appname,Time.now.to_s];;;;;      @threads=[];@app=nil;;;;;;;;;;      self.writelog("App load success: "+appname.to_s);;;;;	 ;;;;;	  if @appshell.to_s!="false";;;;;	    self.shell.start(@apps[-1][-1]);;;;;	  end;;;;;;;;;;	  ;;;;;    rescue => e ; ;;;;;	  self.writelog("App load failed: "+appname.to_s);;;;;	  msg = "App encountered an exception.\n"+e.to_s+"\n"+e.backtrace.join("\n");;;;;	  self.errorlog(msg);;;;;      return msg;;;;;	  ;;;;;    end;;;;;;;;;;  end;;;;;;;;;;  def delete_app(appname);;;;;;;;;;;;;;;  end;;;;;  ;;;;;  def export_app(appname);;;;;  ;;;;;  end;;;;;  ;;;;;  def import_app(filepath);;;;;  ;;;;;  end;;;;;  ;;;;;  ;;;;;  def export_classes(name)  ## add if theres a self.rb put it first;;;;;    if name.to_s.length==0;name=Time.now.to_s;end;;;;;	path=@classdir+"/"+name.to_s+"-definition.rb";;;;;    if Dir.entries(@classdir).length>2;;;;;	  classes=Dir.entries(@classdir)[2..-1];;;;;	  files=[];;;;;	  namesep="#5#;#6#;#9#;#9#;#4#"+";#5#;#6#;#7#;#9#;#6#;#4#";;;;;	  filesep="#8#;#3#;#5#;#3#;#1#"+";#8#;#3#;#5#;#3#;#8#;#5#";;;;;	  first=[];;;;;	  classes.each { |c| ;;;;;	    if c.to_s.downcase=="self.rb";;;;;		  f=File.open(@classdir+"/"+c,"r");first<<["#"+c,f.read];f.close;;;;;		else;f=File.open(@classdir+"/"+c,"r");files<<["#"+c,f.read];f.close ;;;;;		end;;;;;	  };;;;;	  if first.length >0 ;files.each{|f| first << f};files=first;end;;;;;	  joined=[];;;;;	  files.each {|f| joined<< f[0].to_s+namesep+f[1].to_s};;;;;	  files=joined.join(filesep);;;;;      f=File.open(path,"w");f.write(files);f.close;;;;;	  return true;;;;;	else;return "$classdir is empty?";;;;;    end;;;;;  end;;;;;  ;;;;;  #import_classes("E:/rubin/data/definitions/ossy.rb");;;;;  def import_classes(path);;;;;    if File.exist?(path);;;;;	  if Dir.entries(@classdir).length >2 == false;;;;;	    f=File.open(path,"r");definition=f.read;f.close;;;;;	    namesep="#5#;#6#;#9#;#9#;#4#"+";#5#;#6#;#7#;#9#;#6#;#4#";;;;;	    filesep="#8#;#3#;#5#;#3#;#1#"+";#8#;#3#;#5#;#3#;#8#;#5#";;;;;		joined_files=definition.split(filesep);  files=[];;;;;		joined_files.each {|f| files<<f.split(namesep)};;;;;		files.each {|f|;;;;;		  if f.length==0 or f[0].to_s.length == 0;  next;  end;;;;;		  path=@classdir+"/"+f[0].to_s[1..-1];;;;;		  ff=File.open(path,"w");ff.write(f[1].to_s);ff.close;;;;;		};;;;;	    return true;;;;;	  else;return "$classdir is empty?";;;;;	  end;;;;;	else;return "Invalid path";;;;;	end;;;;;  end;;;;;  ;;;;;  ;;;;;  def show_config;;;;;    str="";  cfg=[];  i=0	;;;;;    @config_names.each do |n|;;;;;   	  cfg << n.to_s+"= "+@config[i].to_s;;;;;	  i += 1;;;;;	end;;;;;	str << "\nRubin system config: "+@loaded_cfg_file.to_s+"\n";;;;;	str << cfg.join("\n").to_s+"\n";;;;;	return str;;;;;  end  ;;;;;  ;;;;;  ##fix this stupid shit later;;;;;  alias :config? :show_config;;;;;    ;;;;;   ;;;;;  def change_homedir(str)  ##this should check to see if install headder path matches dir we are changing to;;;;;    if File.directory?(str)# and File.writable?(str);;;;;      opath=@homedir;;;;;	  begin;;;;;	  Dir.chdir(str);;;;;	  $homedir=str;@homedir=str;;;;;	  $sysdir=$homedir+"/system"; @sysdir=@homedir+"/system" ;;;;;      $appdir = $homedir+"/app"; @appdir = @homedir+"/app"   ;;;;;      $classdir=$homedir+"/class"; @classdir=@homedir+"/class"   ;;;;;      $datadir=$homedir+"/data";@datadir=@homedir+"/data"   ;;;;;      $appdatadir = $homedir+"/data/appdata"; @appdatadir = @homedir+"/data/appdata";;;;;      $cfgdir= $homedir+"/data/config"; @cfgdir= @homedir+"/data/config"            ;;;;;      $logdir = $homedir+"/data/logs"; @logdir = @homedir+"/data/logs"         ;;;;;      $userdir = $homedir+"/data/user"; @userdir = @homedir+"/data/user"       ;;;;;      $bindir=$homedir+"/bin"; @bindir=@homedir+"/bin"                ;;;;;	  rescue;Dir.chdir(opath);return false;;;;;	  end;;;;;	  return true;;;;;	else;return false;;;;;	end;;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  ##this is actually really confusing and needs a new name, it launches a ruby file in a new window, thats all, shortcut files have .lnk and host component will be dealing with that;;;;;  def shortcut(str);;;;;    if str[-3..-1].to_s.downcase==".rb";str=str[0..-4];end;;;;;    if File.exist?(@homedir+"/shortcuts/"+str+".rb");;;;;	  odir=Dir.getwd;;;;;	  Dir.chdir(@homedir+"/shortcuts");;;;;	  system("start "+str.to_s+".rb");;;;;	  Dir.chdir(odir);;;;;	  return true;;;;;	  ;;;;;	else;return false;;;;;	end;;;;;  end;;;;;  ;;;;;  def shortcuts?;;;;;    Dir.entries(@homedir+"/shortcuts")[2..-1] ;;;;;  end;;;;;  ;;;;;  ;;;;;  ;;;;;  ;;;;;  def environment?;;;;;     ;;;;;	names=["Shell","Daemond","Threads","Components","Classes",;;;;;	"Definition","Apps Installed","Apps Loaded","Cache File Size"];;;;;;;;;;    entries=[@shell.class.name.to_s,;;;;;	@daemond.class.name.to_s,;;;;;	@daemond.thread_pool.length,;;;;;	@components,;;;;;	@classes,;;;;;	@definitions,;;;;;	@installed_apps,;;;;;	@loaded_apps,;;;;;	@cache.to_s.length];;;;;	;;;;;	;;;;;  end;;;;;  alias :env? :environment?;;;;;  ;;;;;  def help *args;;;;;    if args.length==0;;;;;	  puts "##################################################################";;;;;	  puts "## ";;;;;	  puts "## Welcome to the Rubin system";;;;;	  puts "## ";;;;;	  puts "## ";;;;;	  puts "## ";;;;;	  puts "## More information about the instance variables and methods commonly used in SYSTEM and its components can be read about in the system manual file.";;;;;	  puts "## ";;;;;	  puts "##################################################################";;;;;	elsif args.length==1 and args[0].is_a?(String);;;;;	  found="Object not found in help file.";;;;;	  begin;;;;;	    data=File.read(@datadir+"/help_info.txt");;;;;	    data=eval(data);;;;;	    if data.length>0;;;;;		  data.each do |i|;;;;;		    if i[0].to_s.downcase==args[0].to_s.downcase;;;;;			  found=i[1].to_s;break;;;;;			end;;;;;		  end;;;;;		end;;;;;	  rescue;found="Help file could not be read, it may be corrupted or missing.";;;;;	  end;;;;;	  return found;;;;;	else;;;;;	  return "Pass a method name or object for help info about it.";;;;;	end;;;;;  end;;;;;  ;;;;;  def info?;;;;;    puts "##############################";;;;;    puts "  Rubin system version: "+VERSION.to_s;;;;;	puts "  Ruby Version:         "+RUBY_VERSION.to_s;;;;;	puts "  Rubygems:             ";;;;;	puts "  Host:                 "+ENV["OS"].to_s;;;;;    puts "  Definitions loaded:   "+@definitions.length.to_s;;;;;    puts "  Classes loaded:       "+@classes.length.to_s;;;;;    puts "   ";;;;;    puts "  Boot instance:        "+INSTANCE.to_s;;;;;    puts "  Boot time:            "+BOOTTIME.to_s;;;;;	sec=Time.now-BOOTTIME;;;;;	uptime=Time.parse_seconds(sec);;;;;    puts "  Uptime:               "+uptime.join(":").to_s;;;;;    puts "";;;;;	a=[];;;;;	@apps.each { |aa| a << aa[3].class.to_s };;;;;    puts "  Apps:                 "+@apps.length.to_s + " "+a.to_s;;;;;    puts "  Threads:              "+@daemond.thread_pool.length.to_s;;;;;	puts "  Components:           "+@components.length.to_s + " " + @components.to_s;;;;;    puts "  Debug mode:           "+SYSTEM.config(4).to_s;;;;;    puts "  ";;;;;    puts "  Install directory:    "+INSTALLATION_HEADER[1].to_s;;;;;    puts "  Installation Id:      "+INSTALLATION_HEADER[5].to_s ;;;;;	puts "  Installation Date:    "+INSTALLATION_HEADER[3].to_s;;;;;    puts "  ";;;;;	m=Dir.map(INSTALLATION_HEADER[1].to_s);;;;;    size=0;;;;;	m[0].each { |f| size+=File.size(f)};;;;;	;;;;;	puts "  Installation size:    "+size.to_i.commas;;;;;    puts "  Files:                "+m[0].length.to_s;;;;;    puts "  Directories:          "+m[1].length.to_s;;;;;    puts "  ";;;;;    puts "  Host Identifier:      "+@host_manager.get_host_identifier.to_s;;;;;	puts "";;;;;	internet=false;;;;;	begin;;;;;	  f=URI.open('https://google.com');;;;;	  f.close;;;;;	  internet=true;;;;;	rescue;;;;;	end;;;;;	puts "  Internet Access:      "+internet.to_s;;;;;	puts "";;;;;	;;;;;  end;;;;;;;;;;  ;;;;;  class SystemDaemond  ##System daemond is where automatic system stuff happens, later we will have different daemond versions and store the code internally;;;;;;;;;;    def initialize;;;;;	  unless defined?(@@DAEMOND_RUNNING);@@DAEMOND_RUNNING=true;;;;;	  ;;;;;        thread_pool=[];;;;;	    eval(File.read($sysdir+"/daemond.rb"))  ##this file contains the daemond script;;;;;		;;;;;		if self.instance_variables.length>0;;;;;		  self.instance_variables.each { |iv|;;;;;            thread_pool<<self.instance_variable_get(iv.to_s);;;;;		  ;;;;;		  };;;;;		else## this means the daemond file was empty or corrupted or for some whackey reason didnt contain the daemond script;;;;;		end;;;;;		;;;;;		@running=true;;;;;		@thread_pool=thread_pool ##daemond thread and other system threads.;;;;;		@grave_pool=[] ## where dead threads go for fun;;;;;	  ;;;;;	  end;;;;;	  ;;;;;	  def thread_pool; return @thread_pool; end;;;;;	  ;;;;;	  def grave_pool; return @grave_pool; end;;;;;	  ;;;;;	  def push_thread(thread);;;;;	    if thread.is_a?(Thread);@thread_pool<<thread;end;;;;;	  end;;;;;	  ;;;;;	  def kill;;;;;	    if @thread_pool.length>0;;;;;		  @thread_pool.each { |t| begin ; t.kill ; rescue ;; end };;;;;	      @thread_pool.each {|t| @grave_pool<<t};;;;;		  @thread_pool=[];;;;;		  @running=false;;;;;		  return true;;;;;		else;return false;;;;;		end;;;;;	  end;;;;;	  ;;;;;	  def restart;;;;;	    self.kill;;;;;		eval(File.read($sysdir+"/daemond.rb"));;;;;		@running=true;;;;;		if self.instance_variables.length>0;;;;;		  instance_variables.each { |iv|;;;;;		  ;;;;;			i=self.instance_variable_get(iv.to_s) ;;;;;		    if i.is_a?(Thread);;;;;		      if i.alive?; @thread_pool << i ; end;;;;;		    end;;;;;		  };;;;;		else## this means the daemond file was empty or corrupted or for some whackey reason didnt contain the daemond script;;;;;		end;;;;;		return true;;;;;	  end;;;;;	  ;;;;;	end;;;;;	;;;;;  end;;;;;  ;;;;;  class SystemShell;;;;;    def initialize;;;;;	  @context=nil;;;;;	  @context_history=[];;;;;	  @cid=nil;;;;;	  @log=[];;;;;	  if File.exist?($logdir+"/system_shell.log")==false;;;;;	    f=File.open($logdir+"/system_shell.log","w");f.write("");f.close;;;;;	  end;;;;;	  @password_entry_mode=false;;;;;    end;;;;;    def start *args;;;;;	  if args.length==0;context=MAIN;else;context=args[0];end;;;;;      @main_loop=true;@cid=0;@context=context;;;;;	  while @main_loop   ########################;;;;;	    print @context.class.to_s+":"+@cid.to_s+"<< ";;;;;	    @input = gets.chomp;res=nil;;;;;		@log<<@context.class.to_s+":"+@cid.to_s+"<< "+@input;;;;;;;;;;	    if @input == "exit";@main_loop=false;res="Exiting shell.";;;;;	    elsif @input[0..8]=="*context=" and @input.to_s.length>9;;;;;	      begin;@context=eval(@input.to_s);@context_history<<@context;res="Evaluation context has been changed.";;;;;	      rescue; res = "Unable to change context to: " + @input[8..-1].to_s;;;;;		  end;;;;;		;;;;;		elsif @input.to_s.downcase=="*cls";system("CLS");res=:NO_RESULT;;;;;	    else ##input isnt a builtin command;;;;;	      begin;;;;;	        res = @context.instance_eval(@input);;;;;		  rescue => e;;;;;		    res = "Input caused an exception.\n"+e.to_s+"\n"+e.backtrace[0..1].join("\n");;;;;		  end;;;;;	    end;;;;;	    ;;;;;		unless res==:NO_RESULT;;;;;		  print @context.class.to_s+":"+@cid.to_s+">> "+res.to_s+"\n";;;;;		end;;;;;		@log<<@context.class.to_s+":"+@cid.to_s+">> "+res.to_s+"\n";;;;;	    @cid+=1;@password_entry_mode=false;;;;;	  end##this is the end of the loop ##########;;;;;    end;;;;;	;;;;;	def log(str);;;;;	  f=File.open($logdir+"/system_shell.log","a");f.write(Time.now.to_s+" : "+str.to_s+"\n");f.close;;;;;	end;;;;;  ;;;;;    def stop;;;;;      @main_loop=false;;;;;    end;;;;;  end;;;;;   ;;;;;end;;;;;;;;;;;;;;;SYSTEM=RubinSystem.new    ##initialize the class object first;;;;;SYSTEM.startup            ##initialize things that need the class object to be initialized first;;;;;SYSTEM.start_daemond      ##start system threads;;;;;SYSTEM.post_initialization  ##run autostart apps and maybe shell;;;;;POST_INITIALIZATION=true    ##create a flag to lcok down the startup methods;;;;;##line below might need to be switched on and off in the future;;;;;$system=SYSTEM;;;;;##;##;##;##;##;##;##;##;##;##;##;##;##;##;##;##;##;##;##;##;;;;;##Hidden_Internal_Data=""#1#::#1#::#0#::#0#::#0#::#0#::#0#/rubin/system/ruby.rb#1#::#1#::#0#::#0#::#0#::#0#::#1#require 'bundler/inline';;;;;;;;;;class Ruby_Manager;;;;;  def initialize;;;;;  ;;;;;    @cfgpath=SYSTEM.cfgdir+"/ruby.cfg";;;;;    ;;;;;	@default_config=[];;;;;	@config=@default_config;;;;;    self.load_config;;;;;;;;;;;;;;;    @rubydir=self.locate_host_ruby;;;;;  ;;;;;  end;;;;;;;;;;;;;;;;;;;;  def rubydir;return @rubydir;end;;;;;;;;;;;;;;;;;;;;;;;;;  def load_config;;;;;    if File.file?(@cfgpath);;;;;	  begin;d=File.read(@cfgpath);d=eval(d);@config=d;;;;;	  rescue;SYSTEM.errorlog("Ruby Config could not be loaded, it might be corrupted.");;;;;	  end;;;;;	else;SYSTEM.errorlog("Ruby Config was missing, it had be restored.");;;;;	  f=File.open(@cfgpath,"w");f.write(@default_config.to_s);f.close;;;;;	end  ;;;;;  end;;;;;  ;;;;;  def save_config;;;;;  ;;;;;  end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  def insert_based_launcher;;;;;    ##copy host rubys irb files and insert a rubin launcher before them so rubin will run before irb;;;;;    ##return path to based launcher.;;;;;  end;;;;;;;;;;;;;;;  def locate_host_ruby;;;;;    drive=Dir.getwd.split("/")[0]+"/";;;;;    located=false;;;;;	##check host drive for ruby;;;;;	list=Dir.entries(drive)[2..-1];;;;;	list.each do |pf|;;;;;	  if File.directory?(drive+pf);;;;;        if pf.to_s.downcase[0..3]=="ruby";;;;;          if File.directory?(drive+pf+"/bin");;;;;		    if File.file?(drive+pf+"/bin/ruby.exe");;;;;		      ;;;;;			  located=drive+pf;;;;;			  break;;;;;			end;;;;;		  end;;;;;		end;;;;;      end	  ;;;;;	end;;;;;	##possibly check elsewhere?;;;;;    return located;;;;;  end  ;;;;;;;;;;;;;;;;;;;;;;;;;end